#+TITLE: Emacs Configuration
#+AUTHOR: Toby Slight
#+EMAIL: tslight@pm.me
#+PROPERTY: header-args:emacs-lisp :lexical t
#+PROPERTY: header-args+ :cache yes :comments yes :mkdirp yes :results silent
#+PROPERTY: header-args+ :tangle (expand-file-name "init.el" user-emacs-directory)
#+PROPERTY: header-args+ :tangle-mode (identity #o644)
#+OPTIONS: broken-links:t toc:t num:nil
#+STARTUP: overview
#+EXPORT_FILE_NAME: index
#+SETUPFILE: ./theme-readtheorg.setup

A fairly standard [[https://en.wikipedia.org/wiki/Literate_programming][literate]] Emacs configuration using [[https://orgmode.org/][Org mode]]. *Emacs 29+ ONLY*.

To install, evaluate the code block below with ~C-c C-c~ in an Emacs buffer:

#+begin_src emacs-lisp :tangle no
  (org-babel-tangle) (load init-file) (ts-ensure-byte-compiled-init)
#+end_src

This will tangle all the code blocks below into =~/.emacs.d/init.el=, compile
that file and load it, installing a [[*MELPA Packages][plethora of packages]] along the way.

Be sure to back up your current =~/.emacs.d= with something like ~mv
~/.emacs.d{,.bak}~.

* use-package bootstrap

#+begin_src emacs-lisp
  ;; Allow loading from the package cache.
  (setq package-quickstart t)
  ;; Don't write (package-initialize) to my init file!
  (setq package--init-file-ensured t)
  ;; Turn on ahead-of-time native compilation when installing a package.
  (setq package-native-compile t)
  ;; Setup up archives
  (setq package-archives
        '(("melpa" . "https://melpa.org/packages/")
          ("gnu" . "https://elpa.gnu.org/packages/")))
  (setq use-package-enable-imenu-support t
        use-package-always-defer t
        use-package-verbose t)
  (require 'use-package)
#+end_src

* Settings
** Auto-save

#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
  (setq auto-save-timeout 5)
#+end_src

** Backups

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq backup-by-copying t) ;; copy files, don't rename them.
  (setq delete-old-versions t)
  (setq kept-new-versions 12)
  (setq kept-old-versions 12)
#+end_src

** Bell

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
  (setq visible-bell 1)
#+end_src

** Bookmarks

#+begin_src emacs-lisp
  (setq bookmark-save-flag 1) ;; always save bookmarks to file
#+end_src

** Clipboard

#+begin_src emacs-lisp
  (setq select-enable-clipboard t)
  ;; (setq select-enable-primary t) ;; breaks standard yank meaning that following
  ;; doesn't work as expected:
  (delete-selection-mode t)
  (setq x-select-enable-clipboard-manager nil)
  (setq save-interprogram-paste-before-kill t)
#+end_src

** Code Style

#+begin_src emacs-lisp
  (setq c-default-style "bsd")
  (setq c-basic-offset 4)
  (setq css-indent-offset 2)
  (setq js-indent-level 2)

  ;; If indent-tabs-mode is t, it may use tab, resulting in mixed spaces and tabs
  (setq-default indent-tabs-mode nil)

  ;; make tab key do indent first then completion.
  (setq-default tab-always-indent 'complete)
#+end_src

** Compilation Scroll Output

Place point after complilation error

#+begin_src emacs-lisp
  (setq compilation-scroll-output 'first-error)
#+end_src

** Customize settings file

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+end_src

** Delete all on backspace

#+begin_src emacs-lisp
  (setq backward-delete-char-untabify-method 'all)
#+end_src

** Emacsclient executable

Only tangled on Windows.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) init-file "no")
  ;; https://emacs.stackexchange.com/a/31061
  (when (equal system-type 'windows-nt)
    (if (file-readable-p "C:/Program Files/Emacs/x86_64/bin/emacsclient.exe")
        (setq-default with-editor-emacsclient-executable "C:/Program Files/Emacs/x86_64/bin/emacsclient.exe")
      (setq-default with-editor-emacsclient-executable nil)))
#+end_src

** Enable all advanced features

#+begin_src emacs-lisp
  (setq disabled-command-function nil) ;; enable all "advanced" features
#+end_src

** Encoding

#+begin_src emacs-lisp
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (setq-default default-buffer-file-coding-system 'utf-8-unix)
  (setq coding-system-for-read 'utf-8-unix)
  (setq coding-system-for-write 'utf-8-unix)
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+end_src

** Encryption

#+begin_src emacs-lisp
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)
  (setf epg-pinentry-mode 'loopback)
#+end_src

** Final newline

#+begin_src emacs-lisp
  (setq require-final-newline t) ;; useful for crontab
#+end_src

** History

#+begin_src emacs-lisp
  (setq history-length t)
  (setq history-delete-duplicates t)
#+end_src

** Initial startup

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
  (setq initial-scratch-message nil)
  (setq initial-major-mode 'fundamental-mode)
#+end_src

** Kill Ring Duplicates

#+begin_src emacs-lisp
  (setq kill-do-not-save-duplicates t)
#+end_src

** More extensive apropos

#+begin_src emacs-lisp
  (setq apropos-do-all t) ;; doesn't seem to be documented anywhere..
#+end_src

** More Messages

#+begin_src emacs-lisp
  (setq message-log-max 10000)
#+end_src

** Mouse yank at point

#+begin_src emacs-lisp
  (setq mouse-yank-at-point t)
#+end_src

** Native Compilation

Compile ~elc~ files as needed, in a deferred/async manner.

#+begin_src emacs-lisp
  (when (fboundp 'native-compile-async)
    (setq comp-deferred-compilation t
          comp-deferred-compilation-black-list '("/mu4e.*\\.el$")))
#+end_src

Dealing with system-wide packages:

Some packages like for example mu4e are located in /usr and need root
permissions to be compiled, for them you can run

#+begin_src shell :tangle no
  sudo emacs -Q -batch -L . -f batch-native-compile *.el
#+end_src

** No lockfiles

#+begin_src emacs-lisp
  (setq create-lockfiles nil) ;; prevent creation of .#myfile.ext
#+end_src

** Passwords

#+begin_src emacs-lisp :tangle no
  (setq password-cache t) ; enable password caching
  (setq password-cache-expiry 3600) ; for one hour (time in secs)
#+end_src

** Pop mark on repeat

#+begin_src emacs-lisp
  (setq set-mark-command-repeat-pop t) ;; repeating C-SPC after popping, pops it
#+end_src

** Prefer newer over compiled

If init.elc is older, use newer ~init.el~.

#+begin_src emacs-lisp
  (setq load-prefer-newer t) ;; if init.elc is older, use newer init.el
#+end_src

** Preferred programs

#+begin_src emacs-lisp
  (when (executable-find "rg") (setq grep-program "rg"))
  (when (executable-find "fd") (setq find-program "fd"))
  (when (executable-find "aspell") (setq ispell-program-name "aspell"))
#+end_src

*** Windows Find

First install GnuWin32 binaries from [[http://gnuwin32.sourceforge.net/packages.html][here]].

Or if you want all the GNU tools on your Windows box - use [[https://sourceforge.net/projects/getgnuwin32/files/getgnuwin32/][this]].

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) init-file "no")
  (setq find-program "C:/Program Files (x86)/GnuWin32/bin/find.exe")
  (setq grep-program "C:/Program Files (x86)/GnuWin32/bin/grep.exe")
  (setq xargs-program "C:/Program Files (x86)/GnuWin32/bin/xargs.exe")
#+end_src

** Repeat on final keystroke

#+begin_src emacs-lisp
  (setq repeat-on-final-keystroke t)
#+end_src

** Safe Local Variables

This variables are added to the end of this file.

#+begin_src emacs-lisp
  (setq safe-local-variable-values
        '((eval setq org-confirm-babel-evaluate 'nil)
          (eval setq early-init (expand-file-name "early-init.el" user-emacs-directory))
          (eval setq init-file (expand-file-name "init.el" user-emacs-directory))
          (eval add-hook 'after-save-hook 'org-html-export-to-html nil t)
          (eval add-hook 'after-save-hook 'org-latex-export-to-pdf nil t)
          (eval add-hook 'after-save-hook 'org-twbs-export-to-pdf nil t)
          (eval add-hook 'after-save-hook 'org-babel-tangle nil t)
          (eval add-hook 'after-save-hook (lambda nil (org-export-to-file 'html "index.html") (org-latex-export-to-pdf)) nil t)
          (after-save-hook : (lambda nil (org-export-to-file 'html "index.html") (org-latex-export-to-pdf)))
          (after-save-hook (lambda nil (org-export-to-file 'html "index.html") (org-latex-export-to-pdf)))
          (org-html-validation-link)))
#+end_src

** Scrolling

#+begin_src emacs-lisp
  (setq scroll-step 4)
  (setq scroll-margin 2)
  (setq scroll-conservatively 4)
  (setq scroll-preserve-screen-position t)
#+end_src

#+begin_quote
When enabled, and if your mouse supports it, you can scroll the display up or
down at pixel resolution, according to what your mouse wheel reports. Unlike
pixel-scroll-mode, this mode scrolls the display pixel-by-pixel, as opposed to
only animating line-by-line scrolls.
#+end_quote

#+begin_src emacs-lisp :tangle (if (version< emacs-version "29") "no" init-file)
  (pixel-scroll-precision-mode)
#+end_src

** Sentence End Spaces

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src

** Sort Fold Case

#+begin_src emacs-lisp
  (setq sort-fold-case t)
#+end_src

** Truncate Lines

#+begin_src emacs-lisp
  (set-default 'truncate-lines t)
#+end_src

** Undo limits

#+begin_src emacs-lisp
  (setq undo-limit 80000000)
  (setq undo-strong-limit 90000000)
#+end_src

** Undo save

#+begin_src emacs-lisp
  (add-to-list 'desktop-locals-to-save 'buffer-undo-list)
#+end_src

** Uniquify

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t)
#+end_src

** User info

#+begin_src emacs-lisp
  (setq user-full-name "Toby Slight")
  (setq user-mail-address "tslight@pm.me")
#+end_src

** Windows

#+begin_src emacs-lisp
  (setq split-width-threshold 200)
  (setq split-height-threshold 100)
  (setq auto-window-vscroll nil)
#+end_src

** Logging stuff

https://www.reddit.com/r/emacs/comments/l42oep/suppress_nativecomp_warnings_buffer/

#+begin_src emacs-lisp
  (setq warning-minimum-level :error)
  (setq warning-suppress-types '((comp) (comp) (comp)))
  (setq comp-async-report-warnings-errors 'nil)
  (setq native-comp-async-report-warnings-errors 'nil)
#+end_src

** Yes or no

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p) ;; never have to type full word
  (setq confirm-kill-emacs 'y-or-n-p)
#+end_src

* Keybindings
** Buffers

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

** Editing

#+begin_src emacs-lisp
  (global-set-key (kbd "C-z") 'zap-up-to-char) ; suspend is still bound to C-x C-z
  (global-set-key (kbd "M-z") 'zap-to-char)
#+end_src

Remap some default to saner options

#+begin_src emacs-lisp
  (global-set-key (kbd "M-;") 'comment-line)         ; comment-dwim by default
  (global-set-key (kbd "C-M-;") 'comment-dwim)       ; unbound by default
  (global-set-key (kbd "C-x C-;") 'comment-box)      ; comment-line by default
#+end_src

Always do what I mean!

#+begin_src emacs-lisp
  (global-set-key [remap capitalize-word] 'capitalize-dwim)
  (global-set-key [remap downcase-word] 'downcase-dwim)
  (global-set-key [remap upcase-word] 'upcase-dwim)
#+end_src

** Frames

#+begin_src emacs-lisp
  (global-set-key (kbd "C-<f10>") 'toggle-frame-maximized)
  (global-set-key (kbd "C-<f11>") 'toggle-frame-fullscreen)
  (global-set-key (kbd "C-s-f") 'toggle-frame-fullscreen)
  (global-set-key (kbd "C-s-m") 'toggle-frame-maximized)
#+end_src

** Menubar

#+begin_src emacs-lisp
  (global-set-key (kbd "S-<f10>") 'menu-bar-mode)
#+end_src

** Special mode

#+begin_src emacs-lisp
  ;; for help modes, and simple/special modes
  (define-key special-mode-map "n" #'forward-button)
  (define-key special-mode-map "p" #'backward-button)
  (define-key special-mode-map "f" #'forward-button)
  (define-key special-mode-map "b" #'backward-button)
  (define-key special-mode-map "n" #'widget-forward)
  (define-key special-mode-map "p" #'widget-backward)
  (define-key special-mode-map "f" #'widget-forward)
  (define-key special-mode-map "b" #'widget-backward)
#+end_src

* Theme/UI
** Disable themes

#+begin_src emacs-lisp
  (defadvice load-theme (before theme-dont-propagate activate)
    "Disable theme before loading new one."
    (mapc #'disable-theme custom-enabled-themes))
#+end_src

** Maximize on startup

#+begin_src emacs-lisp
  (setq default-frame-alist '((undecorated . t)
                              (fullscreen . maximized)
                              (vertical-scroll-bars . nil)))
  (setq frame-resize-pixelwise t) ;; jwm resize fix
#+end_src

** Setup Frame for Emacsclient

#+begin_src emacs-lisp
  (defun ts-setup-emacs-nw ()
    "Change some settings to make Emacs more terminal friendly."
    (xterm-mouse-mode 1)
    (mouse-avoidance-mode 'banish)
    (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
    (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
    (global-set-key [mouse-4] '(lambda () (interactive) (scroll-down 1)))
    (global-set-key [mouse-5] '(lambda () (interactive) (scroll-up 1))))
#+end_src

#+begin_src emacs-lisp
  (defun ts-setup-emacs-gui ()
    "Change some settings that are only applicable to graphical Emacs."
    (cond ((eq system-type 'windows-nt) (set-frame-font "Cascadia Mono 11" nil t))
          ((eq system-type 'darwin) (set-frame-font "Monaco 12" nil t))
          ((eq system-type 'gnu/linux) (set-frame-font "Monospace 11" nil t))
          (t (set-frame-font "Monospace 11" nil t))))
#+end_src

#+begin_src emacs-lisp
  (defun ts-after-make-frame (frame)
    "Add custom settings after making the FRAME."
    (select-frame frame)
    (load-theme 'modus-vivendi)
    (if (display-graphic-p)
        (ts-setup-emacs-gui)
      (ts-setup-emacs-nw)))
#+end_src

#+begin_src emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions #'ts-after-make-frame(selected-frame))
    (ts-after-make-frame(selected-frame)))
#+end_src

** Turn off UI elements

#+begin_src emacs-lisp
  (if (not (eq system-type 'darwin))
      (if (fboundp 'menu-bar-mode) (menu-bar-mode -1)))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'tooltip-mode) (tooltip-mode -1))
  (if (fboundp 'set-horizontal-scroll-bar-mode)
      (set-horizontal-scroll-bar-mode nil))
#+end_src

* Buffer Functions
** Encoding

#+begin_src emacs-lisp
  (defun ts-convert-to-unix-coding-system ()
    "Change the current buffer's file encoding to unix."
    (interactive)
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))

  (global-set-key (kbd "C-x RET u") 'ts-convert-to-unix-coding-system)

  (defun ts-hide-dos-eol ()
    "Do not show ^M in files containing mixed UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  (add-hook 'find-file-hook 'ts-hide-dos-eol)
#+end_src

** Indent Buffer

#+begin_src emacs-lisp
  (defun ts-indent-buffer ()
    "Indent the contents of a buffer."
    (interactive)
    (indent-region (point-min) (point-max)))

  (global-set-key (kbd "M-i") 'ts-indent-buffer)
#+end_src

** Kill this buffer

#+begin_src emacs-lisp
  (defun ts-kill-this-buffer ()
    "Kill the current buffer - `kill-this-buffer' is unreliable."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'ts-kill-this-buffer)
#+end_src

** Last buffer

#+begin_src emacs-lisp
  (defun ts-last-buffer ()
    "Switch back and forth between two buffers easily."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (global-set-key (kbd "C-c b") 'ts-last-buffer)
#+end_src

** Nuke buffers

#+begin_src emacs-lisp
  (defun ts-nuke-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapc
     (lambda (buffer)
       (kill-buffer buffer))
     (buffer-list))
    (if current-prefix-arg
        (delete-other-windows)))

  (global-set-key (kbd "C-c M-n") 'ts-nuke-buffers)
#+end_src

** Remove stuff from a buffer

#+begin_src emacs-lisp
  (defun ts-remove-from-buffer (string)
    "Remove all occurences of STRING from the whole buffer."
    (interactive "sString to remove: ")
    (save-match-data
      (save-excursion
        (let ((count 0))
          (goto-char (point-min))
          (while (re-search-forward string (point-max) t)
            (setq count (+ count 1))
            (replace-match "" nil nil))
          (message (format "%d %s removed from buffer." count string))))))

  (defun ts-remove-character-number (number)
    "Remove all occurences of a control character NUMBER.
    Excluding ^I (tabs) and ^J (newline)."
    (if (and (>= number 0) (<= number 31)
             (not (= number 9)) (not (= number 10)))
        (let ((character (string number)))
          (ts-remove-from-buffer character))))

  (defun ts-remove-all-ctrl-characters ()
    "Remove all occurences of all control characters.
    Excluding ^I (tabs) and ^J (newlines)."
    (interactive)
    (mapcar (lambda (n)
              (ts-remove-character-number n))
            (number-sequence 0 31)))

  (defun ts-remove-ctrl-m ()
    "Remove all ^M occurrences from EOL in a buffer."
    (interactive)
    (ts-remove-from-buffer "$"))

  (global-set-key (kbd "C-c k") 'ts-remove-from-buffer)
#+end_src

** Save buffers silently

#+begin_src emacs-lisp
  (defun ts-save-buffers-silently ()
    "Save all open buffers without prompting."
    (interactive)
    (save-some-buffers t)
    (message "Saved all buffers :-)"))

  (global-set-key (kbd "C-c s") 'ts-save-buffers-silently)
#+end_src

* Editing Functions
** Aligning symbols

Some handy functions to make aligning symbols less painful.

#+begin_src emacs-lisp
  (defun ts-align-symbol (begin end symbol)
    "Align any SYMBOL in region (between BEGIN and END)."
    (interactive "r\nsEnter align symbol: ")
    (align-regexp begin end (concat "\\(\\s-*\\)" symbol) 1 1))

  (global-set-key (kbd "C-c a") 'ts-align-symbol)

  (defun ts-align-numbers (begin end)
    "Align numbers in region (between BEGIN and END)."
    (interactive "r")
    (ts-align-symbol begin end "[0-9]+"))

  (global-set-key (kbd "C-c #") 'ts-align-numbers)

  (defadvice align-regexp (around align-regexp-with-spaces activate)
    "Force alignment commands to use spaces, not tabs."
    (let ((indent-tabs-mode nil))
      ad-do-it))
#+end_src

** Beginning of line

#+begin_src emacs-lisp
  (defun ts-move-beginning-of-line ()
    "Move point back to indentation.

  If there is any non blank characters to the left of the cursor.
  Otherwise point moves to beginning of line."
    (interactive)
    (if (= (point) (save-excursion (back-to-indentation) (point)))
        (beginning-of-line)
      (back-to-indentation)))

  (global-set-key [remap move-beginning-of-line] 'ts-move-beginning-of-line)
#+end_src

** Change numbers

Increment or decrement numbers at the point.

#+begin_src emacs-lisp
  (defun ts--change-number (&optional arg)
    "Increment the number forward from point by 'arg'."
    (interactive "p*")
    (save-excursion
      (save-match-data
        (let (inc-by field-width answer)
          (setq inc-by (if arg arg 1))
          (skip-chars-backward "0123456789")
          (when (re-search-forward "[0-9]+" nil t)
            (setq field-width (- (match-end 0) (match-beginning 0)))
            (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
            (when (< answer 0)
              (setq answer (+ (expt 10 field-width) answer)))
            (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                   answer)))))))

  (defun ts-change-number (inc)
    "Adjust the height of the default face by INC.

  INC may be passed as a numeric prefix argument."
    (interactive "p")
    (let ((ev last-command-event)
          (echo-keystrokes nil))
      (let* ((base (event-basic-type ev))
             (step
              (pcase base
                ((or ?+ ?=) inc)
                (?- (- inc))
                (?0 0)
                (_ inc))))
        (ts--change-number step)
        ;; (unless (zerop step)
        (message "Use +,-,0 for further adjustment")
        (set-transient-map
         (let ((map (make-sparse-keymap)))
           (dolist (mods '(() (control)))
             (dolist (key '(?- ?+ ?= ?0)) ;; = is often unshifted +.
               (define-key map (vector (append mods (list key)))
                           (lambda () (interactive) (ts-change-number (abs inc))))))
           map)))))

  (global-set-key (kbd "C-c +") 'ts-change-number)
  (global-set-key (kbd "C-c -") 'ts-change-number)
#+end_src

** Delete inside delimiters

#+begin_src emacs-lisp
  (defun ts-delete-inside-delimiters (arg)
    "Deletes the text within parentheses, brackets or quotes.
  With prefix ARG, delete delimiters too."
    (interactive "P")
    ;; Search for a match on the same line, don't delete across lines
    (search-backward-regexp "[[{(<\"\']" (line-beginning-position))
    (forward-char)
    (let ((lstart (point)))
      (search-forward-regexp "[]})>\"\']" (line-end-position))
      (backward-char)
      (if arg
          (kill-region (- lstart 1) (+ (point) 1))
        (kill-region lstart (point)))))

  (global-set-key (kbd "C-c d") 'ts-delete-inside-delimiters)
#+end_src

** Generate a numbered list

#+begin_src emacs-lisp
  (defun ts-generate-numbered-list (start end char)
    "Create a numbered list from START to END.  Using CHAR as punctuation."
    (interactive "nStart number:\nnEnd number:\nsCharacter:")
    (let ((x start))
      (while (<= x end)
        (insert (concat (number-to-string x) char))
        (newline)
        (setq x (+ x 1)))))
#+end_src

** Kill Region

#+begin_src emacs-lisp
  (defun ts-kill-region (arg)
    "Cut region or current ARG lines to kill ring."
    (interactive "p")
    (let (p1 p2)
      (if (use-region-p)
          (progn (setq p1 (region-beginning))
                 (setq p2 (region-end)))
        (progn (setq p1 (line-beginning-position))
               (setq p2 (line-beginning-position (+ arg 1)))))
      (kill-region p1 p2)))

  (global-set-key [remap kill-region] 'ts-kill-region)
#+end_src

** Kill Ring Save

#+begin_src emacs-lisp
  (defun ts-kill-ring-save (arg)
    "Copy region or current ARG lines to kill ring."
    (interactive "p")
    (let (p1 p2)
      (if (use-region-p)
          (progn (setq p1 (region-beginning))
                 (setq p2 (region-end)))
        (progn (setq p1 (line-beginning-position))
               (setq p2 (line-beginning-position (+ arg 1)))))
      (kill-ring-save p1 p2)
      (goto-char p2)))

  (global-set-key [remap kill-ring-save] 'ts-kill-ring-save)
#+end_src

** Kill Ring Save Whole Buffer

#+begin_src emacs-lisp
  (defun ts-kill-ring-save-whole-buffer ()
    "Save the entire contents of the buffer to the kill ring."
    (interactive)
    (kill-ring-save (point-min) (point-max))
    (message "Saved whole buffer to kill ring :-)"))

  (global-set-key (kbd "C-c h") 'ts-kill-ring-save-whole-buffer)
#+end_src

** Moving lines

#+begin_src emacs-lisp
  (defmacro save-column (&rest body)
    `(let ((column (current-column)))
       (unwind-protect (progn ,@body) (move-to-column column))))
  (put 'save-column 'lisp-indent-function 0)

  (defun move-line-up ()
    (interactive)
    (save-column (transpose-lines 1) (forward-line -2)))

  (defun move-line-down ()
    (interactive)
    (save-column (forward-line 1) (transpose-lines 1) (forward-line -1)))

  (global-set-key (kbd "M-p") 'move-line-up)
  (global-set-key (kbd "M-n") 'move-line-down)
#+end_src

** Sort Words

#+begin_src emacs-lisp
  (defun ts-sort-words (reverse beg end)
    "Sort words in region alphabetically, in REVERSE if negative.

  Prefixed with negative \\[universal-argument], sorts in reverse.

  The variable `sort-fold-case' determines whether alphabetic case
  affects the sort order.

  See `sort-regexp-fields'."
    (interactive "*P\nr")
    (sort-regexp-fields reverse "\\w+" "\\&" beg end))
#+end_src

** Surround stuff

#+begin_src emacs-lisp
  (defun ts-surround (begin end open close)
    "Put OPEN at BEGIN and CLOSE at END of the region.
  If you omit CLOSE, it will reuse OPEN, unless OPEN is a (,{,<,[,
  in which case CLOSE will be the matching pair."
    (interactive  "r\nsStart: \nsEnd: ")
    (save-excursion
      (goto-char end)
      (cond ((string= open "(") (insert ")"))
            ((string= open "[") (insert "]"))
            ((string= open "<") (insert ">"))
            ((string= open "{") (insert "}"))
            ((string= open "") (insert open))
            (t (insert close)))
      (goto-char begin)
      (insert open)))

  (global-set-key (kbd "M-s M-s") 'ts-surround)
#+end_src

** XML pretty print

#+begin_src emacs-lisp
  (defun ts-xml-pretty-print ()
    "Reformat and indent XML."
    (interactive)
    (save-excursion
      (sgml-pretty-print (point-min) (point-max))
      (indent-region (point-min) (point-max))))
#+end_src

* File Functions
** Delete this file

#+begin_src emacs-lisp
  (defun ts-delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (or (buffer-file-name) (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
                               (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name) t)
      (kill-this-buffer)))

  (global-set-key (kbd "C-c f d") 'ts-delete-this-file)
#+end_src

** Make backup of current file

#+begin_src emacs-lisp
  (defun ts-make-backup ()
    "Make a backup copy of current file or dired marked files.

  If in dired, backup current file or marked files."
    (interactive)
    (let (($fname (buffer-file-name)))
      (if $fname
          (let (($backup-name
                 (concat $fname "." (format-time-string "%y%m%d%H%M") ".bak")))
            (copy-file $fname $backup-name t)
            (message (concat "Backup saved at: " $backup-name)))
        (if (string-equal major-mode "dired-mode")
            (progn
              (mapc (lambda ($x)
                      (let (($backup-name
                             (concat $x "." (format-time-string "%y%m%d%H%M") ".bak")))
                        (copy-file $x $backup-name t)))
                    (dired-get-marked-files))
              (message "marked files backed up"))
          (user-error "Buffer not file nor dired")))))
#+end_src

#+begin_src emacs-lisp
  (defun ts-make-backup-and-save ()
    "Backup of current file and save, or backup dired marked files.
  For detail, see `ts-make-backup'."
    (interactive)
    (if (buffer-file-name)
        (progn
          (ts-make-backup)
          (when (buffer-modified-p)
            (save-buffer)))
      (progn
        (ts-make-backup))))

  (global-set-key (kbd "C-c f b") 'ts-make-backup-and-save)
#+end_src

** Open current file as root

#+begin_src emacs-lisp
  (defun ts-sudoedit (&optional arg)
    "Open current or ARG file as root."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (read-file-name "Find file (as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

  (global-set-key (kbd "C-c f s") 'ts-sudoedit)
#+end_src

** Rename file and buffer

#+begin_src emacs-lisp
  (defun ts-rename-this-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "FNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting a file!" name))
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (when (file-exists-p filename)
            (rename-file filename new-name 1))
          (rename-buffer new-name)
          (set-visited-file-name new-name)))))

  (global-set-key (kbd "C-c f r") 'ts-rename-this-file-and-buffer)
#+end_src

** Yank current file contents to kill ring

Very useful for copying ssh public keys...

#+begin_src emacs-lisp
  (defun ts-copy-file-contents-to-clipboard (file)
    "Copy a file's contents to the clipboard."
    (interactive "f")
    (with-current-buffer (find-file-noselect file)
      (kill-new (buffer-substring-no-properties (point-min) (point-max))))
    (message "Copied contents of %s to the clipboard" file))

  (global-set-key (kbd "C-c f h") 'ts-copy-file-contents-to-clipboard)
#+end_src

** Yank current file name to kill ring

#+begin_src emacs-lisp
  (defun ts-copy-file-name-to-clipboard (arg)
    "Copy the current buffer file name to the clipboard.
  With prefix ARG, omit path."
    (interactive "P")
    (let ((filename (if (equal major-mode 'dired-mode)
                        (if arg
                            (file-name-nondirectory
                             (directory-file-name
                              (file-name-directory default-directory)))
                          default-directory)
                      (if arg
                          (file-name-nondirectory buffer-file-name)
                        (buffer-file-name)))))
      (when filename
        (kill-new filename)
        (message "Copied '%s' to the clipboard." filename))))

  (global-set-key (kbd "C-c f w") 'ts-copy-file-name-to-clipboard)
#+end_src

* Miscellaneous
** Byte compile and load on save

#+begin_src emacs-lisp
  (defun ts-byte-compile-and-load ()
    "Byte compile Emacs Lisp files and load if ARG."
    (when (and buffer-file-name
               (equal (file-name-extension buffer-file-name) "el")
               (equal major-mode 'emacs-lisp-mode))
      (byte-compile-file buffer-file-name)
      (message "Compiled %s :-)" buffer-file-name)
      (load (file-name-sans-extension buffer-file-name))
      (message "Loaded %s :-)" buffer-file-name)))

  (add-hook 'after-save-hook 'ts-byte-compile-and-load)
#+end_src

** Ensure init files are byte compiled

This block will byte compile ~early-init.el~ and ~init.el~ if an existing
~.elc~ file is not up to date with their contents.

#+begin_src emacs-lisp
  (defun ts-ensure-byte-compiled-init ()
    "Run `byte-recompile-file' on config files with 'nil' FORCE and ARG 0.
  This means we don't compile if .elc is up to date but we always
  create a new .elc file if it doesn't already exist."
    (autoload 'byte-recompile-file "bytecomp")
    (if (file-readable-p (expand-file-name "early-init.el" user-emacs-directory))
        (byte-recompile-file (expand-file-name "early-init.el" user-emacs-directory) 'nil 0))
    (byte-recompile-file (expand-file-name "init.el" user-emacs-directory) 'nil 0))

  (add-hook 'after-init-hook 'ts-ensure-byte-compiled-init)
#+end_src

** Recompile config

#+begin_src emacs-lisp
  (defvar ts-files-to-recompile '("early-init.el" "init.el")
    "Files under `user-emacs-directory' that we use for configuration.")

  (defun ts-recompile-config ()
    "Recompile everything in Emacs configuration."
    (interactive)
    (mapc (lambda (file)
            (let ((path (expand-file-name file user-emacs-directory)))
              (when (file-readable-p path)
                (byte-recompile-file path t 0)
                (load (file-name-sans-extension path))
                (message "Re-compiled & loaded %s :-)" path))))
          ts-files-to-recompile))
#+end_src

** Tangle config

#+begin_src emacs-lisp
  (defun ts-tangle-config ()
    "Re-tangle my org mode configuration file."
    (interactive)
    (autoload 'org-babel-tangle-file "ob-tangle")
    (org-babel-tangle-file "~/src/emacs/README.org"))
#+end_src

* Window Functions
** Better scrolling of other windows

This is better, since I don't need to send prefix to ~scroll-other-window~.

#+begin_src emacs-lisp
  (defun ts-scroll-other-window (arg)
    "Scroll up other window when called with prefix."
    (interactive "P")
    (if arg (scroll-other-window-down) (scroll-other-window)))

  (global-set-key [remap scroll-other-window] 'ts-scroll-other-window)
#+end_src

** Kill buffer other window

#+begin_src emacs-lisp
  (defun ts-kill-buffer-other-window ()
    "Kill the buffer in the last used window."
    (interactive)
    ;; Window selection is used because point goes to a different window if more
    ;; than 2 windows are present
    (let ((current-window (selected-window))
          (other-window (get-mru-window t t t)))
      (select-window other-window)
      (kill-this-buffer)
      (select-window current-window)))

  (global-set-key (kbd "C-c w k") 'ts-kill-buffer-other-window)
#+end_src

** Switch to the previous window

This is basically ~other-window~ backwards.

#+begin_src emacs-lisp
  (defun ts-prev-window ()
    "Go the previously used window, excluding other frames."
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-x O") 'ts-prev-window)
#+end_src

** Toggle focus to last window

#+begin_src emacs-lisp
  (defun ts-last-window ()
    "Switch back and forth between two windows easily."
    (interactive)
    (let ((win (get-mru-window t t t)))
      (unless win (error "Last window not found"))
      (let ((frame (window-frame win)))
        (raise-frame frame)
        (select-frame frame)
        (select-window win))))

  (global-set-key (kbd "C-c w w") 'ts-last-window)
#+end_src

** Toggle maximize window

#+begin_src emacs-lisp
  (defun ts-toggle-maximize-window ()
    "Temporarily maximize a window."
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (delete-other-windows))))

  (global-set-key (kbd "C-c z") 'ts-toggle-maximize-window)
#+end_src

** Toggle vertical -> horizontal splits

#+begin_src emacs-lisp
  (defun ts-toggle-split ()
    "Switch window split from horizontally to vertically.
  Or vice versa. Change right window to bottom, or change bottom
  window to right."
    (interactive)
    (autoload 'windmove-find-other-window "windmove" nil t)
    (let ((done))
      (dolist (dirs '((right . down) (down . right)))
        (unless done
          (let* ((win (selected-window))
                 (nextdir (car dirs))
                 (neighbour-dir (cdr dirs))
                 (next-win (windmove-find-other-window nextdir win))
                 (neighbour1 (windmove-find-other-window neighbour-dir win))
                 (neighbour2 (if next-win
                                 (with-selected-window next-win
                                   (windmove-find-other-window
                                    neighbour-dir next-win)))))
            (setq done (and (eq neighbour1 neighbour2)
                            (not (eq (minibuffer-window) next-win))))
            (if done
                (let* ((other-buf (window-buffer next-win)))
                  (delete-window next-win)
                  (if (eq nextdir 'right)
                      (split-window-vertically)
                    (split-window-horizontally))
                  (set-window-buffer
                   (windmove-find-other-window neighbour-dir)
                   other-buf))))))))

  (global-set-key (kbd "C-c w s") 'ts-toggle-split)
#+end_src

** Transpose windows

#+begin_src emacs-lisp
  (defun ts-transpose-windows (arg)
    "Transpose windows.  Use prefix ARG to transpose in the other direction."
    (interactive "P")
    (if (not (> (count-windows) 1))
        (message "You can't rotate a single window!")
      (let* ((rotate-times (prefix-numeric-value arg))
             (direction (if (or (< rotate-times 0) (equal arg '(4)))
                            'reverse 'identity)))
        (dotimes (_ (abs rotate-times))
          (dotimes (i (- (count-windows) 1))
            (let* ((w1 (elt (funcall direction (window-list)) i))
                   (w2 (elt (funcall direction (window-list)) (+ i 1)))
                   (b1 (window-buffer w1))
                   (b2 (window-buffer w2))
                   (s1 (window-start w1))
                   (s2 (window-start w2))
                   (p1 (window-point w1))
                   (p2 (window-point w2)))
              (set-window-buffer-start-and-point w1 b2 s2 p2)
              (set-window-buffer-start-and-point w2 b1 s1 p1)))))))

  (define-key ctl-x-4-map "t" 'ts-transpose-windows)
#+end_src

* Emacs Packages
** Ansi Color

#+begin_src emacs-lisp
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
  (defun colorize-compilation-buffer ()
    "ANSI color in compilation buffer."
    (ansi-color-apply-on-region compilation-filter-start (point)))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

#+begin_src emacs-lisp
  (defun ts-display-ansi-colors ()
    (interactive)
    (ansi-color-apply-on-region (point-min) (point-max)))
#+end_src

Make sure we show colors when we run commands with ~M-!~

#+begin_src emacs-lisp
  (defadvice display-message-or-buffer (before ansi-color activate)
    "Process ANSI color codes in shell output."
    (let ((buf (ad-get-arg 0)))
      (and (bufferp buf)
           (string= (buffer-name buf) "*Shell Command Output*")
           (with-current-buffer buf
             (ansi-color-apply-on-region (point-min) (point-max))))))
#+end_src

** Auto-fill

#+begin_src emacs-lisp
  (use-package auto-fill-mode
    :config
    (setq-default fill-column 79)
    (defun ts-fill-or-unfill ()
      "Like `fill-paragraph', but unfill if used twice."
      (interactive)
      (let ((fill-column
             (if (eq last-command 'ts-fill-or-unfill)
                 (progn (setq this-command nil)
                        (point-max))
               fill-column)))
        (call-interactively #'fill-paragraph)))

    (defun ts-unfill-region (beg end)
      "Unfill the region from BEG to END.
  Joining text paragraphs into a single logical line. This is
  useful, e.g., for use with function `visual-line-mode'."
      (interactive "*r")
      (let ((fill-column (point-max)))
        (fill-region beg end)))
    :bind
    ([remap fill-paragraph] . ts-fill-or-unfill)
    ("C-M-q" . ts-unfill-region)
    :hook
    (org-mode . auto-fill-mode)
    (text-mode . auto-fill-mode))
#+end_src

** Auto-revert

#+begin_src emacs-lisp
  (use-package auto-revert :hook (after-init . global-auto-revert-mode))
#+end_src

** Column Number

#+begin_src emacs-lisp
  (use-package column-number-mode :hook (after-init . column-number-mode))
#+end_src

** Dabbrev

#+begin_src emacs-lisp
  (use-package dabbrev
    :config
    (setq abbrev-file-name (concat user-emacs-directory "abbrevs"))
    (setq save-abbrevs 'silently)
    (setq abbrev-suggest t)
    (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
    (setq dabbrev-abbrev-skip-leading-regexp "[$*/=']")
    (setq dabbrev-backward-only nil)
    (setq dabbrev-case-distinction 'case-replace)
    (setq dabbrev-case-fold-search t)
    (setq dabbrev-case-replace 'case-replace)
    (setq dabbrev-check-other-buffers t)
    (setq dabbrev-eliminate-newlines t)
    (setq dabbrev-upcase-means-case-search t))
#+end_src

** Dired

#+begin_src emacs-lisp
  (use-package dired
    :config
    (defun ts-dired-get-size ()
      "Get cumlative size of marked or current item."
      (interactive)
      (let ((files (dired-get-marked-files)))
        (with-temp-buffer
          (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
          (message "Size of all marked files: %s"
                   (progn
                     (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
                     (match-string 1))))))

    (defun ts-dired-beginning-of-buffer ()
      "Go to first file in directory."
      (interactive)
      (goto-char (point-min))
      (dired-next-line 2))

    (defun ts-dired-end-of-buffer ()
      "Go to last file in directory."
      (interactive)
      (goto-char (point-max))
      (dired-next-line -1))

    (defun ts-dired-up-directory ()
      (interactive)
      (find-alternate-file ".."))

    (autoload 'dired-omit-mode "dired-x" nil t)
    (autoload 'dired-omit-files "dired-x" nil t)

    (when (eq system-type 'darwin) (setq dired-listing-switches "-alh"))
    (when (eq system-type 'berkeley-unix) (setq dired-listing-switches "-alhpL"))
    (when (eq system-type 'gnu/linux) (setq dired-listing-switches "-AGFhlv"))

    (setq dired-omit-files "\\`[.]?#\\|\\`[.][.]?\\'\\|^\\..+$"
          dired-dwim-target t
          delete-by-moving-to-trash t
          dired-use-ls-dired nil
          dired-recursive-copies 'always
          dired-recursive-deletes 'always)

    :bind (:map dired-mode-map
                (")" . dired-omit-mode)
                ("<" . ts-dired-beginning-of-buffer)
                (">" . ts-dired-end-of-buffer)
                ("?" . ts-dired-get-size)
                ("b" . ts-dired-up-directory)
                ("c" . dired-do-compress-to)
                ("f" . 'dired-find-alternate-file)))
#+end_src

*** Dired AUX

#+begin_src emacs-lisp
  (use-package dired-aux
    :after dired
    :config
    (setq dired-isearch-filenames 'dwim)
    (setq dired-create-destination-dirs 'ask)
    (setq dired-vc-rename-file t))
#+end_src

*** Find Dired

#+begin_src emacs-lisp
  (use-package find-dired
    :config
    (setq find-ls-option '("-ls" . "-AGFhlv"))
    (setq find-name-arg "-iname"))
#+end_src

*** Writeable Dired

#+begin_src emacs-lisp
  (use-package wdired
    :config
    (setq wdired-allow-to-change-permissions t)
    (setq wdired-create-parent-directories t))
#+end_src

** Doc View

#+begin_src emacs-lisp
  (use-package doc-view-mode
    :config
    (setq doc-view-continuous t)
    (setq doc-view-resolution 300))
#+end_src

** Ediff

#+begin_src emacs-lisp
  (use-package ediff
    :config
    (setq ediff-diff-options "-w")
    (setq ediff-keep-variants nil)
    (setq ediff-make-buffers-readonly-at-startup nil)
    (setq ediff-merge-revisions-with-ancestor t)
    (setq ediff-show-clashes-only t)
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    ;; https://emacs.stackexchange.com/a/24602
    (defun disable-y-or-n-p (orig-fun &rest args)
      "Advise ORIG-FUN with ARGS so it dynamically rebinds `y-or-n-p'."
      (cl-letf (((symbol-function 'y-or-n-p) (lambda () t)))
        (apply orig-fun args)))
    (advice-add 'ediff-quit :around #'disable-y-or-n-p)
    :hook
    (ediff-after-quit-hook-internal . winner-undo))
#+end_src

** Eglot

Emacs Polyglot: an Emacs LSP client that stays out of your way.

https://github.com/joaotavora/eglot

The Language Server Protocol (LSP) defines the protocol used between an editor
or IDE and a language server that provides language features like auto
complete, go to definition, find all references etc. The goal of the Language
Server Index Format (LSIF, pronounced like "else if") is to support rich code
navigation in development tools or a Web UI without needing a local copy of the
source code.

https://microsoft.github.io/language-server-protocol/

#+begin_src shell :tangle no
  pip install python-lsp-server
  go install golang.org/x/tools/gopls@latest
  npm install -g typescript-language-server typescript
  npm install -g bash-language-server
  npm install -g dockerfile-language-server-nodejs
#+end_src

#+begin_src emacs-lisp
  (use-package eglot
    :hook
    (prog-mode . eglot-ensure)
    (shell-script-mode . eglot-ensure))
#+end_src

** Eldoc

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
  (add-hook 'lisp-mode-hook 'eldoc-mode)
#+end_src

** Electric

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'electric-indent-mode)
  ;; (add-hook 'text-mode-hook 'electric-quote-mode)
  (add-hook 'after-init-hook 'electric-pair-mode)
#+end_src

** ERC

#+begin_src emacs-lisp
  (use-package erc
    :config
    (setq erc-autojoin-channels-alist '(("freenode.net" "#emacs")))
    (setq erc-fill-column 80)
    (setq erc-hide-list '("JOIN" "PART" "QUIT"))
    (setq erc-input-line-position -2)
    (setq erc-keywords '("knowayback"))
    (setq erc-nick "knowayback")
    (setq erc-prompt-for-password t)
    (setq erc-track-enable-keybindings t))
#+end_src

** Eshell

#+begin_src emacs-lisp
  (use-package eshell
    :config
    (defun ts-eshell-prompt ()
      "Custom eshell prompt."
      (concat
       (propertize (user-login-name) 'face `(:foreground "green" ))
       (propertize "@" 'face `(:foreground "yellow"))
       (propertize (system-name) `face `(:foreground "green"))
       (propertize ":" 'face `(:foreground "yellow"))
       (if (string= (eshell/pwd) (getenv "HOME"))
           (propertize "~" 'face `(:foreground "magenta"))
         (propertize (eshell/basename (eshell/pwd)) 'face `(:foreground "magenta")))
       "\n"
       (if (= (user-uid) 0)
           (propertize "#" 'face `(:foreground "red"))
         (propertize "$" 'face `(:foreground "yellow")))
       (propertize " " 'face `(:foreground "white"))))
    ;; https://www.emacswiki.org/emacs/EshellPrompt
    (setq eshell-cd-on-directory t
          eshell-destroy-buffer-when-process-dies t
          eshell-highlight-prompt nil
          eshell-hist-ignoredups t
          eshell-history-size 4096
          eshell-ls-use-colors t
          eshell-prefer-lisp-functions t
          eshell-prefer-lisp-variables t
          eshell-prompt-regexp "^[^#$\n]*[#$] "
          eshell-prompt-function 'ts-eshell-prompt
          eshell-review-quick-commands nil
          eshell-save-history-on-exit t
          eshell-smart-space-goes-to-end t
          eshell-where-to-jump 'begin)
    (add-to-list 'eshell-modules-list 'eshell-tramp)
    :bind
    ("C-c e" . eshell)
    :hook
    (eshell-preoutput-filter-functions . ansi-color-apply))
#+end_src

** Flymake

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'flymake-mode)
#+end_src

** Flyspell

Don't bother using this on Windows as I can rather be bothered to install
[[http://aspell.net/win32/][Aspell]] for Windows.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (unless (eq system-type 'windows-nt)
    (add-hook 'text-mode-hook 'flyspell-mode)
    (add-hook 'org-mode-hook 'flyspell-mode)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))
#+end_src

** Gnus

#+begin_src emacs-lisp
  (use-package gnus
    :config
    (setq gnus-init-file "~/.emacs.d/init.el")
    (setq gnus-home-directory "~/.emacs.d/")
    (setq message-directory "~/.emacs.d/mail")
    (setq gnus-directory "~/.emacs.d/news")
    (setq nnfolder-directory "~/.emacs.d/mail/archive")
    (setq gnus-use-full-window nil)
    (setq gnus-select-method '(nntp "news.gwene.org"))
    ;; (setq gnus-secondary-select-methods '((nntp "news.gnus.org")))
    (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)
    (setq gnus-thread-hide-subtree t)
    (setq gnus-thread-ignore-subject t)
    :commands (gnus))
#+end_src

** Hide/Show

#+begin_src emacs-lisp
  (add-hook 'shell-script-mode-hook 'hs-minor-mode)
  (add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

** Highlight line

#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'hl-line-mode)
  (add-hook 'org-mode-hook 'hl-line-mode)
  (add-hook 'prog-mode-hook 'hl-line-mode)
  (add-hook 'shell-script-mode-hook 'hl-line-mode)
  (add-hook 'text-mode-hook 'hl-line-mode)
#+end_src

** Hippie Expand

#+begin_src emacs-lisp
  (defun ts-hippie-expand-completions (&optional hippie-expand-function)
    "Return the full list of completions generated by HIPPIE-EXPAND-FUNCTION.
  The optional argument can be generated with `make-hippie-expand-function'."
    (let ((this-command 'ts-hippie-expand-completions)
          (last-command last-command)
          (buffer-modified (buffer-modified-p))
          (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
      (cl-flet ((ding)) ; avoid the (ding) when hippie-expand exhausts its options.
        (while (progn
                 (funcall hippie-expand-function nil)
                 (setq last-command 'ts-hippie-expand-completions)
                 (not (equal he-num -1)))))
      ;; Evaluating the completions modifies the buffer, however we will finish
      ;; up in the same state that we began.
      (set-buffer-modified-p buffer-modified)
      ;; Provide the options in the order in which they are normally generated.
      (delete he-search-string (reverse he-tried-table))))

  (defun ts-hippie-complete-with (hippie-expand-function)
    "Offer `completing-read' using the specified HIPPIE-EXPAND-FUNCTION."
    (let* ((options (ts-hippie-expand-completions hippie-expand-function))
           (selection (and options (completing-read "Completions: " options))))
      (if selection
          (he-substitute-string selection t)
        (message "No expansion found"))))

  (defun ts-hippie-expand-completing-read ()
    "Offer `completing-read' for the word at point."
    (interactive)
    (ts-hippie-complete-with 'hippie-expand))

  (global-set-key (kbd "M-/") 'hippie-expand)
  (global-set-key (kbd "C-M-/") 'ts-hippie-expand-completing-read)
#+end_src

** Icomplete

#+begin_src emacs-lisp
  (use-package icomplete
    :config
    (icomplete-vertical-mode)
    (setq icomplete-delay-completions-threshold 100)
    (setq icomplete-max-delay-chars 2)
    (setq icomplete-compute-delay 0.2)
    (setq icomplete-show-matches-on-no-input t)
    (setq icomplete-hide-common-prefix nil)
    (setq icomplete-prospects-height 1)
    (setq icomplete-separator (propertize " · " 'face 'shadow))
    (setq icomplete-with-completion-tables t)
    (setq icomplete-tidy-shadowed-file-names t)
    (setq icomplete-in-buffer t)
    (defun ts-icomplete-styles ()
      (setq-local completion-styles '(initials flex partial-completion substring basic)))
    :hook
    (after-init . fido-mode)
    (icomplete-minibuffer-setup . ts-icomplete-styles)
    :bind (:map icomplete-minibuffer-map
                ("C-j" . icomplete-fido-exit)
                ("M-j" . exit-minibuffer)
                ("C-n" . icomplete-forward-completions)
                ("C-p" . icomplete-backward-completions)
                ("C-s" . icomplete-forward-completions)
                ("C-r" . icomplete-backward-completions)
                ("<up>" . icomplete-backward-completions)
                ("<down>" . icomplete-forward-completions)
                ("<left>" . icomplete-backward-completions)
                ("<right>" . icomplete-forward-completions)))
#+end_src

** Imenu

#+begin_src emacs-lisp
  (use-package imenu
    :config
    (setq imenu-auto-rescan t)
    (setq imenu-auto-rescan-maxout 600000)
    (setq imenu-eager-completion-buffer t)
    (setq imenu-level-separator "/")
    (setq imenu-max-item-length 100)
    (setq imenu-space-replacement " ")
    (setq imenu-use-markers t)
    (setq imenu-use-popup-menu nil)
    :bind
    ("C-c i" . imenu))
#+end_src

** Line Numbers

#+begin_src emacs-lisp
  (setq display-line-numbers 'relative)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'sh-script-hook 'display-line-numbers-mode)
#+end_src

** Minibuffer
*** Completion framework settings

#+begin_src emacs-lisp
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-ignore-case t)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completions-detailed t)
  (setq completions-format 'one-column)
#+end_src

*** Misc Minibuffer settings

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
  (setq file-name-shadow-mode 1)
  (setq minibuffer-depth-indicate-mode 1)
  (setq minibuffer-eldef-shorten-default t)
  (setq minibuffer-electric-default-mode 1)
  (setq read-answer-short t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq resize-mini-windows t)
#+end_src

*** Save history mode

#+begin_src emacs-lisp
  (use-package savehist
    :config
    (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
    (setq savehist-save-minibuffer-history 1)
    :hook (after-init . savehist-mode))
#+end_src

** Occur

#+begin_src emacs-lisp
  (add-hook 'occur-mode-hook 'hl-line-mode)
  (define-key occur-mode-map "t" 'toggle-truncate-lines)
#+end_src

** Org

#+begin_src emacs-lisp
  (use-package org
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((awk . t)
       (C . t)
       (clojure . t)
       (css . t)
       (dot . t) ;; graphviz language
       (emacs-lisp . t)
       (gnuplot . t)
       (haskell . t)
       (java . t)
       (js . t)
       (latex . t)
       (lisp . t)
       (makefile . t)
       (ocaml . t)
       (perl . t)
       (python . t)
       (plantuml . t)
       (ruby . t)
       (scheme . t)
       (sed . t)
       (shell . t)
       (sql . t)
       (sqlite . t)))
    (setq org-capture-templates
          '(("t" "TODO Entry" entry (file+headline "~/org/todo.org" "Captured")
             "* TODO %?\n  %i\n  %a")
            ("j" "Journal Entry" entry (file+datetree "~/org/journal.org" "Captured")
             "* %?\nEntered on %U\n %i\n  %a")
            ("n" "Notes Entry" entry (file+datetree "~/org/notes.org" "Captured")
             "* %?\nEntered on %U\n %i\n  %a")))
    (setq org-latex-listings 'minted)
    (setq org-latex-pdf-process
          '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (setq org-startup-folded t) ; start in overview mode
    (setq org-directory "~/org")
    (setq org-agenda-files (file-expand-wildcards "~/org/*.org"))
    (setq org-default-notes-file "~/org/notes.org")
    (setq org-image-actual-width nil) ; try to get width from #+ATTR.* keyword
    (setf org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))
    (setq org-emphasis-regexp-components '(" \t('\"{" "- \t.,:!?;'\")}\\" " \t\r\n,\"'" "." 300))
    (setq org-confirm-babel-evaluate 'nil)
    (setq org-export-with-toc t)
    (setq org-indent-indentation-per-level 1)
    (setq org-list-allow-alphabetical t)
    (setq org-list-indent-offset 1)
    (setq org-return-follows-link t)
    (setq org-startup-indented t)
    (setq org-html-validation-link nil) ; don't add "validate" postamble
    (setq org-use-fast-todo-selection t)
    (setq org-goto-interface 'outline-path-completionp)
    (setq org-outline-path-complete-in-steps nil)
    (setq org-refile-use-outline-path 'file)
    (setq org-refile-allow-creating-parent-nodes 'confirm)
    (setq org-refile-targets '((nil :maxlevel . 9)))
    (setq org-special-ctrl-a/e 'reversed)
    (setq org-special-ctrl-k t)
    (setq org-special-ctrl-o t)
    (setq org-use-speed-commands t)
    (setq org-speed-commands-user '(("N" . org-down-element) ("P" . org-up-element)))
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-src-window-setup 'current-window)
    (setq org-structure-template-alist (append org-structure-template-alist
                                               '(("cl" . "src common-lisp")
                                                 ("el" . "src emacs-lisp")
                                                 ("go" . "src go")
                                                 ("ja" . "src java")
                                                 ("js" . "src javascript")
                                                 ("kr" . "src c")
                                                 ("py" . "src python")
                                                 ("sh" . "src shell")
                                                 ("sq" . "src sql")
                                                 ("tx" . "src text"))))
    :bind (:map org-mode-map ("C-c i" . org-goto))
    :hook (org-babel-post-tangle . emacs-lisp-byte-compile-and-load))
#+end_src

** Pending delete

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'pending-delete-mode 1) ;; remove selected region if typing
#+end_src

** Prettify Symbols

#+begin_src emacs-lisp
  (use-package prettify-symbols
    :config (setq prettify-symbols-unprettify-at-point 'right-edge)
    :hook (after-init . global-prettify-symbols-mode))
#+end_src

** Project

#+begin_src emacs-lisp
  (use-package project
    :config
    (setq ts-project-roots '("~"))
    (setq project-switch-commands
          '((?b "Buffer" project-switch-to-buffer)
            (?c "Compile" project-compile)
            (?d "Dired" project-dired)
            (?e "Eshell" project-eshell)
            (?f "File" project-find-file)
            (?g "Grep" project-find-regexp)
            (?q "Query replace" project-query-replace-regexp)
            (?r "Run command" project-async-shell-command)
            (?s "Search" project-search)
            (?v "VC dir" project-vc-dir)))

    (defun ts-project--git-repo-p (directory)
      "Return non-nil if there is a git repository in DIRECTORY."
      (and
       (file-directory-p (concat directory "/.git"))
       (file-directory-p (concat directory "/.git/info"))
       (file-directory-p (concat directory "/.git/objects"))
       (file-directory-p (concat directory "/.git/refs"))
       (file-regular-p (concat directory "/.git/HEAD"))))

    (defun ts-project--git-repos-recursive (directory maxdepth)
      "List git repos in under DIRECTORY recursively to MAXDEPTH."
      (let* ((git-repos '())
             (current-directory-list
              (directory-files directory t directory-files-no-dot-files-regexp)))
        ;; while we are in the current directory
        (if (ts-project--git-repo-p directory)
            (setq git-repos (cons (file-truename (expand-file-name directory)) git-repos)))
        (while current-directory-list
          (let ((f (car current-directory-list)))
            (cond ((and (file-directory-p f)
                        (file-readable-p f)
                        (> maxdepth 0)
                        (not (ts-project--git-repo-p f)))
                   (setq git-repos
                         (append git-repos
                                 (ts-project--git-repos-recursive f (- maxdepth 1)))))
                  ((ts-project--git-repo-p f)
                   (setq git-repos (cons
                                    (file-truename (expand-file-name f)) git-repos))))
            (setq current-directory-list (cdr current-directory-list))))
        (delete-dups git-repos)))

    (defun ts-project--list-projects ()
      "Produce list of projects in `ts-project-roots'."
      (let ((cands (delete-dups (mapcan (lambda (directory)
                                          (ts-project--git-repos-recursive
                                           (expand-file-name directory)
                                           10))
                                        ts-project-roots))))
        ;; needs to be a list of lists
        (mapcar (lambda (d)
                  (list (abbreviate-file-name d)))
                cands)))

    (defun ts-project-update-projects ()
      "Overwrite `project--list' using `ts-project--list-projects'.
        WARNING: This will destroy & replace the contents of `project-list-file'."
      (interactive)
      (autoload 'project--ensure-read-project-list "project" nil t)
      (project--ensure-read-project-list)
      (setq project--list (ts-project--list-projects))
      (project--write-project-list)
      (message "Updated project list in %s" project-list-file))

    :bind
    ("C-x pu" . ts-project-update-projects))
#+end_src

** Python

#+begin_src emacs-lisp
  (use-package python :config (setq python-fill-docstring-style 'django))
#+end_src

** Recentf

#+begin_src emacs-lisp
  (use-package recentf
    :config
    (setq recentf-exclude '(".gz"
                            ".xz"
                            ".zip"
                            "/elpa/"
                            "/ssh:"
                            "/sudo:"
                            "^/var/folders\\.*"
                            "COMMIT_EDITMSG\\'"
                            ".*-autoloads\\.el\\'"
                            "[/\\]\\.elpa/"))
    (setq recentf-max-menu-items 128)
    (setq recentf-max-saved-items 256)
    (defun ts--recentf-get-paths ()
      "Return de-duplicated and abbreviated `recentf-list'."
      (delete-dups (mapcar 'abbreviate-file-name recentf-list)))
    (defun ts-recentf-find-file ()
      "`find-file' using `recentf-list'."
      (interactive)
      (find-file (completing-read "Find file: " (ts--recentf-get-paths))))
    (defun ts-recentf-find-file-other-window ()
      "`find-file' using `recentf-list'."
      (interactive)
      (find-file-other-window
       (completing-read "Find file in other window: " (ts--recentf-get-paths))))
    (defun ts-recentf-find-file-other-frame ()
      "`find-file' using `recentf-list'."
      (interactive)
      (find-file-other-frame
       (completing-read "Find file in other frame: " (ts--recentf-get-paths))))
    :bind
    ("C-c r" . ts-recentf-find-file)
    ("C-c 4 r" . ts-recentf-find-file-other-window)
    ("C-c 5 r" . ts-recentf-find-file-other-frame)
    ("C-c C-r" . recentf-open-files)
    :hook
    (after-init . recentf-mode))
#+end_src

** Saveplace

#+begin_src emacs-lisp
  (use-package save-place
    :config (setq save-place-file (concat user-emacs-directory "saveplace.el"))
    :hook (after-init . save-place-mode))
#+end_src

** Semantic

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'semantic-mode)
  ;; https://github.com/abo-abo/lispy/issues/473
  (advice-add 'semantic-idle-scheduler-function :around #'ignore)
#+end_src

** Shell Script

#+begin_src emacs-lisp
  (setq auto-mode-alist (append auto-mode-alist
                                '(("\\.sh\\'" . shell-script-mode)
                                  ("\\.bash.*\\'" . shell-script-mode)
                                  ("\\.zsh.*\\'" . shell-script-mode)
                                  ("\\.aliases\\'" . shell-script-mode)
                                  ("\\.functions\\'" . shell-script-mode)
                                  ("\\bashrc\\'" . shell-script-mode)
                                  ("\\kshrc\\'" . shell-script-mode)
                                  ("\\profile\\'" . shell-script-mode)
                                  ("\\zshenv\\'" . shell-script-mode)
                                  ("\\zprompt\\'" . shell-script-mode)
                                  ("\\zshrc\\'" . shell-script-mode)
                                  ("\\prompt_.*_setup\\'" . shell-script-mode))))

  (setq interpreter-mode-alist (append interpreter-mode-alist
                                       '(("bash" . shell-script-mode)
                                         ("ksh" . shell-script-mode)
                                         ("sh" . shell-script-mode)
                                         ("zsh" . shell-script-mode))))

  (with-eval-after-load 'sh-script
    (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
    (message "Lazy loaded shell-script-mode :-)"))
#+end_src

** Show paren

#+begin_src emacs-lisp
  (use-package paren
    :config
    (setq show-paren-when-point-in-periphery t)
    (setq show-paren-when-point-inside-paren t)
    :hook (after-init . show-paren-mode))
#+end_src

** Size Indication

#+begin_src emacs-lisp :tangle no
  (add-hook 'after-init-hook 'size-indication-mode)
#+end_src

** Subword

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'global-subword-mode) ;; move by camel case, etc
#+end_src

** Term
*** ANSI Term launcher

#+begin_src emacs-lisp
  (defun ts-ansi-term ()
    "Opens shell from $SHELL environmental variable in `ansi-term'."
    (interactive)
    ;; https://emacs.stackexchange.com/a/48481
    (let ((switch-to-buffer-obey-display-actions))
      (ansi-term (getenv "SHELL"))))

  (global-set-key (kbd "C-c tt") 'ts-ansi-term)

  (defun ts-ansi-term-other-window ()
    "Opens default $SHELL `ansi-term' in another window."
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (ts-ansi-term))

  (global-set-key (kbd "C-c 4 tt") 'ts-ansi-term-other-window)
#+end_src

*** Set term coding system to UTF-8

#+begin_src emacs-lisp
  (add-hook 'term-exec (lambda () (set-process-coding-system 'utf-8-unix 'utf-8-unix)))
#+end_src

*** Switch to ANSI Term

#+begin_src emacs-lisp
  (defun ts-switch-to-ansi-term ()
    "Open an `ansi-term' if it doesn't already exist.
  Otherwise switch to current one."
    (interactive)
    (if (get-buffer "*ansi-term*")
        (switch-to-buffer "*ansi-term*")
      (ansi-term (getenv "SHELL"))))

  (global-set-key (kbd "C-c ts") 'ts-switch-to-ansi-term)

  (defun ts-switch-to-ansi-term-other-window()
    "Does what it states on the tin!"
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (ts-switch-to-ansi-term))

  (global-set-key (kbd "C-c 4 ts") 'ts-switch-to-ansi-term-other-window)
#+end_src

*** Term Advise

#+begin_src emacs-lisp
  (with-eval-after-load 'term
    (defadvice term-handle-exit (after term-kill-buffer-on-exit activate)
      "Kill term when shell exits."
      (kill-buffer))
    (setq term-buffer-maximum-size 200000)
    (message "Lazy loaded term :-)"))
#+end_src

** Time

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'time
    (setq display-time-format "%H:%M %d/%m")
    (setq display-time-default-load-average 'nil))
  (add-hook 'after-init-hook 'display-time-mode)
#+end_src

** Tramp

#+begin_src emacs-lisp
  (with-eval-after-load 'tramp
    (setq tramp-backup-directory-alist backup-directory-alist)
    (setq tramp-default-method "ssh")
    (setf tramp-persistency-file-name (concat temporary-file-directory "tramp-" (user-login-name)))
    (message "Lazy loaded tramp :-)"))
#+end_src

** Version Control

[[https://protesilaos.com/dotemacs/#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Protesilaos Stavrou's VC reference]]

#+begin_src emacs-lisp
  (use-package vc
    :config
    (setq vc-follow-symlinks t)
    (setq vc-make-backup-files t)
    (setq version-control t)
    :bind ("C-x v d" . vc-dir-root))
#+end_src

** View mode

Provide pager-like keybindings. Makes navigating read-only buffers a breeze.
Move down and up with SPC and delete (backspace) or S-SPC, half a page down and
up with d and u, and isearch with s.

Prolific emacser Omar Antolin Camarena points out a built-in way to use
view-mode in all read-only buffers, including ones you set read-only with C-x
C-q.

#+begin_src emacs-lisp
  (setq view-read-only t)
#+end_src

** Whitespace

#+begin_src emacs-lisp
  (use-package whitespace
    :config
    (setq whitespace-line-column 120)
    (setq whitespace-style '(face
                             tabs
                             spaces
                             trailing
                             lines
                             space-before-tab::space
                             newline
                             indentation::space
                             empty
                             space-after-tab::space
                             space-mark
                             tab-mark
                             newline-mark)
          whitespace-face 'whitespace-trailing)
    :bind ("C-c M-w" . whitespace-mode)
    :hook (before-save . whitespace-cleanup))
#+end_src

** Windmove

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c w b") 'windmove-left)
  (global-set-key (kbd "C-c w f") 'windmove-right)
  (global-set-key (kbd "C-c w p") 'windmove-up)
  (global-set-key (kbd "C-c w n") 'windmove-down)

  (global-set-key (kbd "C-c w C-b") 'windmove-swap-states-left)
  (global-set-key (kbd "C-c w C-f") 'windmove-swap-states-right)
  (global-set-key (kbd "C-c w C-p") 'windmove-swap-states-up)
  (global-set-key (kbd "C-c w C-n") 'windmove-swap-states-down)

  (with-eval-after-load 'windmove
    (setq windmove-wrap-around t)
    (message "Lazy loaded windmove :-)"))
#+end_src

** Window Divider

#+begin_src emacs-lisp
  (setq window-divider-default-right-width 1)
  (setq window-divider-default-bottom-width 1)
  (setq window-divider-default-places 'right-only)
  (add-hook 'window-setup-hook 'window-divider-mode)
#+end_src

** Winner mode

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Startup-Summary.html#Startup-Summary][Startup Summary]]

#+begin_src emacs-lisp
  (add-hook 'window-setup-hook 'winner-mode)
  (global-set-key (kbd "C-c w u") 'winner-undo)
  (global-set-key (kbd "C-c w r") 'winner-redo)
#+end_src

* MELPA Packages

I like to split up my "vanilla" Emacs configuration and custom functions from
the customisations provided by third party libraries.

If you want to go for a more vanilla setup, just prefix the ~COMMENT~ keyword
to the tile above, and re-tangle the file.

This way it makes it very easy to run a semi-stock Emacs without ~package.el~
or any third party libraries, but still have some saner defaults and some extra
functionality.

** Ansible

#+begin_src emacs-lisp
  (use-package ansible :ensure :hook (yaml-mode . ansible))
#+end_src

#+begin_src emacs-lisp
  (use-package ansible-doc :ensure :hook (yaml-mode . ansible-doc-mode))
#+end_src

** Async

#+begin_src emacs-lisp
  (use-package async :ensure :defer 5
    :commands (async-byte-compile-file
               async-bytecomp-package-mode)
    :init
    (unless (equal system-type 'windows-nt)
      (setq async-bytecomp-allowed-packages '(all)))
    :config
    (if (equal system-type 'windows-nt)
        (async-bytecomp-package-mode -1)
      (async-bytecomp-package-mode 1))
    :hook (dired-mode-hook . dired-async-mode))
#+end_src

** Blacken

#+begin_src emacs-lisp
  (use-package blacken :ensure :hook (python-mode . blacken-mode))
#+end_src

** Default Text Scale

Increase or decrease font size everywhere with ~C-M-=~ and ~C-M--~

https://github.com/purcell/default-text-scale

#+begin_src emacs-lisp
  (use-package default-text-scale :ensure :defer 7 :config (default-text-scale-mode))
#+end_src

** Diminish

#+begin_src emacs-lisp
  (use-package diminish :ensure :defer 2
    :diminish abbrev-mode
    :diminish auto-fill-function ;; wtf?!
    :diminish eldoc-mode
    :diminish hs-minor-mode
    :diminish highlight-changes-mode
    :diminish ts-key-mode
    :diminish org-indent-mode
    :diminish org-src-mode
    :diminish subword-mode
    :hook
    (org-indent-mode . (lambda () (diminish 'org-indent-mode)))
    (hs-minor-mode . (lambda () (diminish 'hs-minor-mode))))
#+end_src

** Docker

#+begin_src emacs-lisp
  (use-package dockerfile-mode :ensure)
#+end_src

** Exec path from shell

Don't tangle this block if ~system-type~ is ~windows-nt~.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package exec-path-from-shell :ensure :defer 10
    :unless (eq system-type 'windows-nt)
    :commands exec-path-from-shell-initialize
    :init
    (setq exec-path-from-shell-check-startup-files 'nil)
    :config
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-env "DEVPATH")
    (exec-path-from-shell-copy-env "PYTHONPATH"))
#+end_src

** Flycheck

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package flycheck :ensure
    :unless (eq system-type 'windows-nt)
    :diminish flycheck-mode
    :config
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    :hook
    (prog-mode . flycheck-mode)
    (shell-script-mode . flycheck-mode))
#+end_src

** Git
*** Gitlab CI

#+begin_src emacs-lisp
  (use-package gitlab-ci-mode :ensure
    :mode
    "\\.gitlab-ci.yaml\\'"
    "\\.gitlab-ci.yml\\'"
    :hook
    (yaml-mode . hs-minor-mode))
#+end_src

*** Git Timemachine

#+begin_src emacs-lisp
  (use-package git-timemachine :ensure)
#+end_src

*** Magit

#+begin_src emacs-lisp
  (use-package magit :ensure
    :bind*
    ("C-x g" . magit-status)
    :config
    (when (eq system-type 'windows-nt)
      (if (file-readable-p "C:/Program Files/Git/bin/git.exe")
          (setq magit-git-executable "C:/Program Files/Git/bin/git.exe"))
      (when (file-directory-p "C:/Program Files/Git/bin")
        (setq exec-path (add-to-list 'exec-path "C:/Program Files/Git/bin"))
        (setenv "PATH" (concat "C:\\Program Files\\Git\\bin;" (getenv "PATH")))))
    (setq magit-clone-set-remote.pushDefault t)
    (setq magit-completing-read-function 'magit-builtin-completing-read))
#+end_src

#+begin_src emacs-lisp
  (use-package magit-repos
    :bind* ("C-x C-g" . magit-list-repositories)
    :config
    (setq magit-repository-directories `(("~/" . 0)
                                         ("~/src" . 10)
                                         ("~/oe-developers" . 10)))
    (setq magit-repolist-columns
          '(("Flag" 5 magit-repolist-column-flags ((:right-align t) nil))
            ("Name" 20 magit-repolist-column-ident nil)
            ("Branch" 10 magit-repolist-column-branch nil)
            ;; ("Version" 25 magit-repolist-column-version nil)
            ("Pull" 5 magit-repolist-column-unpulled-from-upstream ((:right-align t) nil))
            ("Push" 5 magit-repolist-column-unpushed-to-upstream ((:right-align t) nil))
            ;; ("Pull" 5 magit-repolist-column-unpulled-from-pushremote ((:right-align t) nil))
            ;; ("Push" 5 magit-repolist-column-unpushed-to-pushremote ((:right-align t) nil))
            ("Path" 99 magit-repolist-column-path nil)))
    (setq magit-repolist-sort-key '("Flag" . t)))
#+end_src

** Go mode

#+begin_src emacs-lisp
  (use-package go-mode :ensure
    :config
    (defun ts-go-indent ()
      (setq indent-tabs-mode 1)
      (setq tab-width 2))
    :hook
    (go-mode . ts-go-indent)
    (before-save . gofmt-before-save))
#+end_src

** Hungry delete

#+begin_src emacs-lisp
  (use-package hungry-delete :ensure :defer 6 :config (global-hungry-delete-mode))
#+end_src

** JSON

#+begin_src emacs-lisp
  (use-package json-mode :ensure
    :config
    (defun ts-json-mode-setup ()
      (json-mode)
      (json-pretty-print (point-min) (point-max))
      (goto-char (point-min))
      (set-buffer-modified-p nil))
    (add-to-list 'auto-mode-alist
                 '("\\.json\\'" . 'ts-json-mode-setup)))
#+end_src

** Markdown

#+begin_src emacs-lisp
  (use-package markdown-mode :ensure
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . gfm-mode)
           ("\\.markdown\\'" . gfm-mode))
    :init (setq markdown-command "multimarkdown"))
#+end_src

** Org
*** htmlize

#+begin_src emacs-lisp
  (use-package htmlize :ensure)
#+end_src

** Powershell

#+begin_src emacs-lisp
  (use-package powershell :ensure :mode (("\\.ps1\\'" . powershell-mode)))
#+end_src

** Restclient

#+begin_src emacs-lisp
  (use-package restclient :ensure)
#+end_src

** systemd

Don't tangle this block if ~system-type~ is ~windows-nt~.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package systemd :ensure :unless (equal system-type 'windows-nt))
#+end_src

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode :ensure)
#+end_src

** Trashed

#+begin_src emacs-lisp
  (use-package trashed :ensure :bind ("C-c f t" . trashed))
#+end_src

** Web Mode

#+begin_src emacs-lisp
  (use-package web-mode :ensure
    :mode
    "\\.phtml\\'"
    "\\.tpl\\.php\\'"
    "\\.[agj]sp\\'"
    "\\.as[cp]x\\'"
    "\\.erb\\'"
    "\\.mustache\\'"
    "\\.djhtml\\'"
    "\\.html\\.twig\\'"
    "\\.html?\\'"
    "\\.php?\\'"
    "\\.css?\\'"
    :hook
    (web-mode . js2-minor-mode)
    :config
    (setq web-mode-content-type "jsx"
          web-mode-enable-auto-quoting nil
          web-mode-code-indent-offset 2
          web-mode-markup-indent-offset 2
          web-mode-attr-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-enable-auto-pairing t
          web-mode-enable-css-colorization t
          web-mode-enable-block-face t
          web-mode-enable-part-face t
          web-mode-enable-comment-keywords t)
    (add-to-list 'web-mode-indentation-params '("lineup-args" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-calls" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-concats" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-ternary" . nil)))
#+end_src

** Which Key

#+begin_src emacs-lisp
  (use-package which-key :ensure :defer 5 :config (which-key-mode))
#+end_src

** Writeable Grep

#+begin_src emacs-lisp
  (use-package wgrep :ensure :commands wgrep
    :bind (:map grep-mode-map
                ("e" . wgrep-change-to-wgrep-mode)
                ("C-x C-q" . wgrep-change-to-wgrep-mode)))
#+end_src

** YAML

#+begin_src emacs-lisp
  (use-package highlight-indentation :ensure)
#+end_src

#+begin_src emacs-lisp
  (use-package yaml-mode :ensure
    :hook
    (yaml-mode . highlight-indentation-mode)
    (yaml-mode . hs-minor-mode)
    (yaml-mode . display-line-numbers-mode))
#+end_src

** Yasnippet

#+begin_src emacs-lisp
  (use-package yasnippet :ensure :hook (prog-mode . yas-minor-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package yasnippet-classic-snippets :ensure)
#+end_src

#+begin_src emacs-lisp
  (use-package yasnippet-snippets :ensure)
#+end_src

* COMMENT Local Variables                                  :NOEXPORT:ARCHIVE:
# Local Variables:
# eval: (setq org-confirm-babel-evaluate 'nil)
# eval: (setq init-file (expand-file-name "init.el" user-emacs-directory))
# eval: (setq early-init (expand-file-name "early-init.el" user-emacs-directory))
# eval: (add-hook 'after-save-hook 'org-babel-tangle nil t)
# End:
