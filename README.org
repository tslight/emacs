#+TITLE: Emacs Configuration
#+AUTHOR: Toby Slight
#+EMAIL: tslight@pm.me
#+PROPERTY: header-args:emacs-lisp :lexical t
#+PROPERTY: header-args+ :cache yes :comments yes :mkdirp yes :results silent
#+PROPERTY: header-args+ :tangle (expand-file-name "init.el" user-emacs-directory)
#+PROPERTY: header-args+ :tangle-mode (identity #o644)
#+OPTIONS: broken-links:t toc:t num:nil
#+STARTUP: overview
#+EXPORT_FILE_NAME: index
#+SETUPFILE: ./theme-readtheorg.setup

A fairly standard [[https://en.wikipedia.org/wiki/Literate_programming][literate]] Emacs configuration using [[https://orgmode.org/][Org mode]]. *Emacs 26+ ONLY*.

To install, evaluate the code block below with ~C-c C-c~ in an Emacs buffer:

#+begin_src emacs-lisp :tangle no
  (org-babel-tangle)
  (if (not (version< emacs-version "27")) (load early-init))
  (load init-file)
  (ts-ensure-byte-compiled-init)
#+end_src

This will tangle all the code blocks below into =~/.emacs.d/init.el=, compile
that file and load it, installing a [[*MELPA Packages][plethora of packages]] along the way.

Be sure to back up your current =~/.emacs.d= with something like ~mv
~/.emacs.d{,.bak}~.

* Lexical Binding

This must come at the beginning of the file

[[https://nullprogram.com/blog/2016/12/22/][Some Performance Advantages of Lexical Scope]]

#+NAME: lexical-binding
#+begin_src emacs-lisp :comments no
  ;; -*- lexical-binding: t; -*-
#+end_src

And one for =~/.emacs.d/early-init.el= if it exists...

#+begin_src emacs-lisp :noweb yes :comments no :tangle (if (version< emacs-version "27") "no" early-init)
  <<lexical-binding>>
#+end_src

* [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][Doom Speed Hacks]]
** Avoid garbage collection at startup

The GC can easily double startup time, so we suppress it at startup by
turning up gc-cons-threshold (and perhaps gc-cons-percentage) temporarily:

#+begin_src emacs-lisp :tangle (if (version< emacs-version "27") init-file early-init)
  (setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
        gc-cons-percentage 0.6)
#+end_src

It is important to reset the garbage collection settings eventually. Not
doing so will cause garbage collection freezes during long-term interactive
use. Conversely, a gc-cons-threshold that is too small will cause
stuttering. We use 16mb as our default.

#+begin_src emacs-lisp :tangle (if (version< emacs-version "27") init-file early-init)
  (defun ts-default-gc-cons-settings ()
    (setq gc-cons-threshold 16777216 ; 16mb
          gc-cons-percentage 0.1))
  (add-hook 'emacs-startup-hook 'ts-default-gc-cons-settings)
#+end_src

** Unset file-name-handler-alist temporarily

Emacs consults this variable every time a file is read or library loaded, or
when certain functions in the file API are used (like expand-file-name or
file-truename).

Emacs does this to check if a special handler is needed to read that file, but
none of them are (typically) necessary at startup, so we disable them
(temporarily!):

#+begin_src emacs-lisp :tangle (if (version< emacs-version "27") init-file early-init)
  (defvar ts-default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+end_src

Don’t forget to restore file-name-handler-alist, otherwise TRAMP won’t work and
compressed/encrypted files won’t open.

#+begin_src emacs-lisp :tangle (if (version< emacs-version "27") init-file early-init)
  (defun ts-restore-default-file-name-handler-alist ()
    (setq file-name-handler-alist ts-default-file-name-handler-alist))
  (add-hook 'emacs-startup-hook 'ts-restore-default-file-name-handler-alist)
#+end_src

* Settings
** Auto-save

#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
  (setq auto-save-timeout 5)
#+end_src

** Backups

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq backup-by-copying t) ;; copy files, don't rename them.
  (setq delete-old-versions t)
  (setq kept-new-versions 12)
  (setq kept-old-versions 12)
#+end_src

** Bell

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
  (setq visible-bell 1)
#+end_src

** Bookmarks

#+begin_src emacs-lisp
  (setq bookmark-save-flag 1) ;; always save bookmarks to file
#+end_src

** Clipboard

#+begin_src emacs-lisp
  (setq select-enable-clipboard t)
  (setq select-enable-primary t)
  (setq x-select-enable-clipboard-manager nil)
  (setq save-interprogram-paste-before-kill t)
#+end_src

** Code Style

#+begin_src emacs-lisp
  (setq c-default-style "bsd")
  (setq c-basic-offset 4)
  (setq css-indent-offset 2)
  (setq js-indent-level 2)

  ;; If indent-tabs-mode is t, it may use tab, resulting in mixed spaces and tabs
  (setq-default indent-tabs-mode nil)

  ;; make tab key do indent first then completion.
  (setq-default tab-always-indent 'complete)
#+end_src

** Compilation Scroll Output

Place point after complilation error

#+begin_src emacs-lisp
  (setq compilation-scroll-output 'first-error)
#+end_src

** Customize settings file

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+end_src

** Delete all on backspace

#+begin_src emacs-lisp
  (setq backward-delete-char-untabify-method 'all)
#+end_src

** Emacsclient executable

Only tangled on Windows.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) init-file "no")
  ;; https://emacs.stackexchange.com/a/31061
  (when (equal system-type 'windows-nt)
    (if (file-readable-p "C:/Program Files/Emacs/x86_64/bin/emacsclient.exe")
        (setq-default with-editor-emacsclient-executable "C:/Program Files/Emacs/x86_64/bin/emacsclient.exe")
      (setq-default with-editor-emacsclient-executable nil)))
#+end_src

** Enable all advanced features

#+begin_src emacs-lisp
  (setq disabled-command-function nil) ;; enable all "advanced" features
#+end_src

** Encoding

#+begin_src emacs-lisp
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (setq-default default-buffer-file-coding-system 'utf-8-unix)
  (setq coding-system-for-read 'utf-8-unix)
  (setq coding-system-for-write 'utf-8-unix)
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+end_src

** Encryption

#+begin_src emacs-lisp
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)
  (setf epg-pinentry-mode 'loopback)
#+end_src

** Final newline

#+begin_src emacs-lisp
  (setq require-final-newline t) ;; useful for crontab
#+end_src

** History

#+begin_src emacs-lisp
  (setq history-length t)
  (setq history-delete-duplicates t)
#+end_src

** Initial startup

#+begin_src emacs-lisp
  (defun display-startup-echo-area-message ()
    "Redefine this function to be more useful."
    (message "Started in %s. Hacks & Glory await! :-)" (emacs-init-time)))
  (setq inhibit-startup-screen t)
  (setq initial-scratch-message nil)
  (setq initial-major-mode 'fundamental-mode)
#+end_src

** Kill Ring Duplicates

#+begin_src emacs-lisp
  (setq kill-do-not-save-duplicates t)
#+end_src

** More extensive apropos

#+begin_src emacs-lisp
  (setq apropos-do-all t) ;; doesn't seem to be documented anywhere..
#+end_src

** More Messages

#+begin_src emacs-lisp
  (setq message-log-max 10000)
#+end_src

** Mouse yank at point

#+begin_src emacs-lisp
  (setq mouse-yank-at-point t)
#+end_src

** Native Compilation

Compile ~elc~ files as needed, in a deferred/async manner.

#+begin_src emacs-lisp
  (when (fboundp 'native-compile-async)
    (setq comp-deferred-compilation t
          comp-deferred-compilation-black-list '("/mu4e.*\\.el$")))
#+end_src

Dealing with system-wide packages:

Some packages like for example mu4e are located in /usr and need root
permissions to be compiled, for them you can run

#+begin_src shell :tangle no
  sudo emacs -Q -batch -L . -f batch-native-compile *.el
#+end_src

** No lockfiles

#+begin_src emacs-lisp
  (setq create-lockfiles nil) ;; prevent creation of .#myfile.ext
#+end_src

** COMMENT Passwords

#+begin_src emacs-lisp :tangle no
  (setq password-cache t) ; enable password caching
  (setq password-cache-expiry 3600) ; for one hour (time in secs)
#+end_src

** Pop mark on repeat

#+begin_src emacs-lisp
  (setq set-mark-command-repeat-pop t) ;; repeating C-SPC after popping, pops it
#+end_src

** Prefer newer over compiled

If init.elc is older, use newer ~init.el~.

#+begin_src emacs-lisp
  (setq load-prefer-newer t) ;; if init.elc is older, use newer init.el
#+end_src

** Repeat on final keystroke

#+begin_src emacs-lisp
  (setq repeat-on-final-keystroke t)
#+end_src

** Safe Local Variables

This variables are added to the end of this file.

#+begin_src emacs-lisp
  (setq safe-local-variable-values
        '((eval setq early-init (expand-file-name "early-init.el" user-emacs-directory))
          (eval setq init-file (expand-file-name "init.el" user-emacs-directory))
          (eval add-hook 'after-save-hook 'org-html-export-to-html nil t)
          (eval add-hook 'after-save-hook 'org-latex-export-to-pdf nil t)
          (eval add-hook 'after-save-hook 'org-twbs-export-to-pdf nil t)
          (eval add-hook 'after-save-hook 'org-babel-tangle nil t)
          (eval add-hook 'after-save-hook (lambda nil (org-export-to-file 'html "index.html") (org-latex-export-to-pdf)) nil t)
          (after-save-hook : (lambda nil (org-export-to-file 'html "index.html") (org-latex-export-to-pdf)))
          (after-save-hook (lambda nil (org-export-to-file 'html "index.html") (org-latex-export-to-pdf)))
          (org-html-validation-link)))
#+end_src

** Scrolling

#+begin_src emacs-lisp
  (setq scroll-step 4)
  (setq scroll-margin 2)
  (setq scroll-conservatively 4)
  (setq scroll-preserve-screen-position t)
#+end_src

#+begin_quote
When enabled, and if your mouse supports it, you can scroll the display up or
down at pixel resolution, according to what your mouse wheel reports. Unlike
pixel-scroll-mode, this mode scrolls the display pixel-by-pixel, as opposed to
only animating line-by-line scrolls.
#+end_quote

#+begin_src emacs-lisp :tangle (if (version< emacs-version "29") "no" init-file)
  (pixel-scroll-precision-mode)
#+end_src

** Sentence End Spaces

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src
** Sort Fold Case

When do I ever want to sort case sensitively?!

#+begin_src emacs-lisp
  (setq sort-fold-case t)
#+end_src

** Truncate Lines

#+begin_src emacs-lisp
  (set-default 'truncate-lines t)
#+end_src

** Undo limits

#+begin_src emacs-lisp
  ;; http://www.dr-qubit.org/Lost_undo-tree_history.html
  (setq undo-limit 80000000)
  (setq undo-strong-limit 90000000)
#+end_src

** Undo save

#+begin_src emacs-lisp
  (add-to-list 'desktop-locals-to-save 'buffer-undo-list)
#+end_src

** Uniquify

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t)
#+end_src

** User info

#+begin_src emacs-lisp
  (setq user-full-name "Toby Slight")
  (setq user-mail-address "tslight@pm.me")
#+end_src

** Windows

#+begin_src emacs-lisp
  (setq split-width-threshold 200)
  (setq split-height-threshold 100)
  (setq auto-window-vscroll nil)
#+end_src

** Logging stuff

https://www.reddit.com/r/emacs/comments/l42oep/suppress_nativecomp_warnings_buffer/

#+begin_src emacs-lisp
  (setq warning-minimum-level :error)
  (setq warning-suppress-types '((comp) (comp) (comp)))
  (setq comp-async-report-warnings-errors 'nil)
  (setq native-comp-async-report-warnings-errors 'nil)
#+end_src

** Yes or no

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p) ;; never have to type full word
  (setq confirm-kill-emacs 'y-or-n-p)
#+end_src

* Keybindings
** Buffers

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c M-l") 'lisp-interaction-mode)
  (global-set-key (kbd "C-x c") 'save-buffers-kill-emacs)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "C-x M-k") 'kill-buffer)
#+end_src

#+begin_src emacs-lisp
  (unless (version< emacs-version "28") ; Emacs 28
    (let ((map ctl-x-x-map))
      (define-key map "e" #'eval-buffer)))
#+end_src

** Browse Url

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x M-b") 'browse-url-of-file)
#+end_src

** Calculator

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c c") 'calculator)
  (global-set-key (kbd "C-c M-c") 'calc)
#+end_src

** Editing

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-e") 'pp-eval-last-sexp)
  (global-set-key (kbd "C-z") 'zap-up-to-char) ; suspend is still bound to C-x C-z
  (global-set-key (kbd "M-z") 'zap-to-char)
  (global-set-key (kbd "C-x M-t") 'transpose-regions)
  (global-set-key (kbd "C-x M-p") 'transpose-paragraphs)
#+end_src

Remap some default to saner options

#+begin_src emacs-lisp
  (global-set-key (kbd "M-%") 'query-replace-regexp) ; regex all the things!
  (global-set-key (kbd "M-;") 'comment-line)         ; comment-dwim by default
  (global-set-key (kbd "C-M-;") 'comment-dwim)       ; unbound by default
  (global-set-key (kbd "C-x C-;") 'comment-box)      ; comment-line by default
  (global-set-key (kbd "M-o") 'delete-blank-lines)   ; this is on C-x C-o by default
  (global-set-key (kbd "M-SPC") 'cycle-spacing)      ; just-one-space by default
#+end_src

Always do what I mean!

#+begin_src emacs-lisp
  (global-set-key [remap capitalize-word] 'capitalize-dwim)
  (global-set-key [remap downcase-word] 'downcase-dwim)
  (global-set-key [remap upcase-word] 'upcase-dwim)
#+end_src

** Eval

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x M-e b") (lambda () (interactive) (eval-buffer) (message "Evaluated buffer")))
  (global-set-key (kbd "C-x M-e d") (lambda () (interactive) (eval-defun) (message "Evaluated function")))
  (global-set-key (kbd "C-x M-e r") (lambda () (interactive) (eval-region) (message "Evaluated region")))
#+end_src

** Frames

#+begin_src emacs-lisp
  (global-set-key (kbd "C-<f10>") 'toggle-frame-maximized)
  (global-set-key (kbd "C-<f11>") 'toggle-frame-fullscreen)
  (global-set-key (kbd "C-s-f") 'toggle-frame-fullscreen)
  (global-set-key (kbd "C-s-m") 'toggle-frame-maximized)
#+end_src

** Menubar

#+begin_src emacs-lisp
  (global-set-key (kbd "S-<f10>") 'menu-bar-mode)
#+end_src

** Registers

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x j") 'jump-to-register)
#+end_src

** Special mode

#+begin_src emacs-lisp
  ;; for help modes, and simple/special modes
  (define-key special-mode-map "n" #'forward-button)
  (define-key special-mode-map "p" #'backward-button)
  (define-key special-mode-map "f" #'forward-button)
  (define-key special-mode-map "b" #'backward-button)
  (define-key special-mode-map "n" #'widget-forward)
  (define-key special-mode-map "p" #'widget-backward)
  (define-key special-mode-map "f" #'widget-forward)
  (define-key special-mode-map "b" #'widget-backward)
#+end_src

* Theme/UI
** Disable themes

#+begin_src emacs-lisp
  (defadvice load-theme (before theme-dont-propagate activate)
    "Disable theme before loading new one."
    (mapc #'disable-theme custom-enabled-themes))
#+end_src

** Maximize on startup

#+begin_src emacs-lisp
  (setq default-frame-alist '((undecorated . t)
                              (fullscreen . maximized)
                              (vertical-scroll-bars . nil)))
  (setq frame-resize-pixelwise t) ;; jwm resize fix
#+end_src

** Setup Frame for Emacsclient

#+begin_src emacs-lisp
  (defun ts-setup-emacs-nw ()
    "Change some settings to make Emacs more terminal friendly."
    (xterm-mouse-mode 1)
    (mouse-avoidance-mode 'banish)
    (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
    (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
    (global-set-key [mouse-4] '(lambda () (interactive) (scroll-down 1)))
    (global-set-key [mouse-5] '(lambda () (interactive) (scroll-up 1))))
#+end_src

#+begin_src emacs-lisp
  (defun ts-setup-emacs-gui ()
    "Change some settings that are only applicable to graphical Emacs."
    (cond ((eq system-type 'windows-nt) (set-frame-font "Cascadia Mono 11" nil t))
          ((eq system-type 'darwin) (set-frame-font "Monaco 12" nil t))
          ((eq system-type 'gnu/linux) (set-frame-font "Monospace 11" nil t))
          (t (set-frame-font "Monospace 11" nil t))))
#+end_src

#+begin_src emacs-lisp
  (defun ts-after-make-frame (frame)
    "Add custom settings after making the FRAME."
    (select-frame frame)
    (if (version< emacs-version "28")
        (load-theme 'wombat)
      (load-theme 'modus-vivendi))
    (if (display-graphic-p)
        (ts-setup-emacs-gui)
      (ts-setup-emacs-nw)))
#+end_src

#+begin_src emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions #'ts-after-make-frame(selected-frame))
    (ts-after-make-frame(selected-frame)))
#+end_src

** Turn off UI elements

#+begin_src emacs-lisp
  (if (not (eq system-type 'darwin))
      (if (fboundp 'menu-bar-mode) (menu-bar-mode -1)))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'tooltip-mode) (tooltip-mode -1))
  (if (fboundp 'set-horizontal-scroll-bar-mode)
      (set-horizontal-scroll-bar-mode nil))
#+end_src

* Buffer Functions
** Encoding

#+begin_src emacs-lisp
  (defun ts-convert-to-unix-coding-system ()
    "Change the current buffer's file encoding to unix."
    (interactive)
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))

  (global-set-key (kbd "C-x RET u") 'ts-convert-to-unix-coding-system)

  (defun ts-hide-dos-eol ()
    "Do not show ^M in files containing mixed UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  (add-hook 'find-file-hook 'ts-hide-dos-eol)
#+end_src

** Indent Buffer

#+begin_src emacs-lisp
  (defun ts-indent-buffer ()
    "Indent the contents of a buffer."
    (interactive)
    (indent-region (point-min) (point-max)))

  (global-set-key (kbd "M-i") 'ts-indent-buffer)
#+end_src

** Kill this buffer

#+begin_src emacs-lisp
  (defun ts-kill-this-buffer ()
    "Kill the current buffer - `kill-this-buffer' is unreliable."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'ts-kill-this-buffer)
#+end_src

** Last buffer

#+begin_src emacs-lisp
  (defun ts-last-buffer ()
    "Switch back and forth between two buffers easily."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (global-set-key (kbd "C-c b") 'ts-last-buffer)
#+end_src

** Narrow DWIM

#+begin_src emacs-lisp
  (defun ts-narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens, otherwise, it narrows intelligently.

  Intelligently means: region, org-src-block, org-subtree, or
  defun, whichever applies first.

  Narrowing to org-src-block actually calls `org-edit-src-code'.
  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  (define-key ctl-x-map "n" 'ts-narrow-or-widen-dwim)
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-x n") 'ts-narrow-or-widen-dwim))
#+end_src

** Nuke buffers

#+begin_src emacs-lisp
  (defun ts-nuke-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapc
     (lambda (buffer)
       (kill-buffer buffer))
     (buffer-list))
    (if current-prefix-arg
        (delete-other-windows)))

  (global-set-key (kbd "C-c M-n") 'ts-nuke-buffers)
#+end_src

** COMMENT Remove stuff from a buffer

#+begin_src emacs-lisp
  (defun ts-remove-from-buffer (string)
    "Remove all occurences of STRING from the whole buffer."
    (interactive "sString to remove: ")
    (save-match-data
      (save-excursion
        (let ((count 0))
          (goto-char (point-min))
          (while (re-search-forward string (point-max) t)
            (setq count (+ count 1))
            (replace-match "" nil nil))
          (message (format "%d %s removed from buffer." count string))))))

  (defun ts-remove-character-number (number)
    "Remove all occurences of a control character NUMBER.
    Excluding ^I (tabs) and ^J (newline)."
    (if (and (>= number 0) (<= number 31)
             (not (= number 9)) (not (= number 10)))
        (let ((character (string number)))
          (ts-remove-from-buffer character))))

  (defun ts-remove-all-ctrl-characters ()
    "Remove all occurences of all control characters.
    Excluding ^I (tabs) and ^J (newlines)."
    (interactive)
    (mapcar (lambda (n)
              (ts-remove-character-number n))
            (number-sequence 0 31)))

  (defun ts-remove-ctrl-m ()
    "Remove all ^M occurrences from EOL in a buffer."
    (interactive)
    (ts-remove-from-buffer "$"))

  (global-set-key (kbd "C-c k") 'ts-remove-from-buffer)
#+end_src

** Save buffers silently

#+begin_src emacs-lisp
  (defun ts-save-buffers-silently ()
    "Save all open buffers without prompting."
    (interactive)
    (save-some-buffers t)
    (message "Saved all buffers :-)"))

  (global-set-key (kbd "C-c s") 'ts-save-buffers-silently)
#+end_src

* Editing Functions
** Aligning symbols

Some handy functions to make aligning symbols less painful.

#+begin_src emacs-lisp
  (defun ts-align-symbol (begin end symbol)
    "Align any SYMBOL in region (between BEGIN and END)."
    (interactive "r\nsEnter align symbol: ")
    (align-regexp begin end (concat "\\(\\s-*\\)" symbol) 1 1))

  (global-set-key (kbd "C-c a") 'ts-align-symbol)

  (defun ts-align-numbers (begin end)
    "Align numbers in region (between BEGIN and END)."
    (interactive "r")
    (ts-align-symbol begin end "[0-9]+"))

  (global-set-key (kbd "C-c #") 'ts-align-numbers)

  (defadvice align-regexp (around align-regexp-with-spaces activate)
    "Force alignment commands to use spaces, not tabs."
    (let ((indent-tabs-mode nil))
      ad-do-it))
#+end_src

** Beginning of line

#+begin_src emacs-lisp
  (defun ts-move-beginning-of-line ()
    "Move point back to indentation.

  If there is any non blank characters to the left of the cursor.
  Otherwise point moves to beginning of line."
    (interactive)
    (if (= (point) (save-excursion (back-to-indentation) (point)))
        (beginning-of-line)
      (back-to-indentation)))

  (global-set-key [remap move-beginning-of-line] 'ts-move-beginning-of-line)
#+end_src

** COMMENT Case insensitive sort-lines

#+begin_src emacs-lisp
  (defun ts-sort-lines-nocase ()
    "Sort marked lines with case sensitivity."
    (interactive)
    (let ((sort-fold-case t))
      (call-interactively 'sort-lines)))
#+end_src

** Change numbers

Increment or decrement numbers at the point.

#+begin_src emacs-lisp
  (defun ts--change-number (&optional arg)
    "Increment the number forward from point by 'arg'."
    (interactive "p*")
    (save-excursion
      (save-match-data
        (let (inc-by field-width answer)
          (setq inc-by (if arg arg 1))
          (skip-chars-backward "0123456789")
          (when (re-search-forward "[0-9]+" nil t)
            (setq field-width (- (match-end 0) (match-beginning 0)))
            (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
            (when (< answer 0)
              (setq answer (+ (expt 10 field-width) answer)))
            (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                   answer)))))))

  (defun ts-change-number (inc)
    "Adjust the height of the default face by INC.

  INC may be passed as a numeric prefix argument."
    (interactive "p")
    (let ((ev last-command-event)
          (echo-keystrokes nil))
      (let* ((base (event-basic-type ev))
             (step
              (pcase base
                ((or ?+ ?=) inc)
                (?- (- inc))
                (?0 0)
                (_ inc))))
        (ts--change-number step)
        ;; (unless (zerop step)
        (message "Use +,-,0 for further adjustment")
        (set-transient-map
         (let ((map (make-sparse-keymap)))
           (dolist (mods '(() (control)))
             (dolist (key '(?- ?+ ?= ?0)) ;; = is often unshifted +.
               (define-key map (vector (append mods (list key)))
                 (lambda () (interactive) (ts-change-number (abs inc))))))
           map)))))

  (global-set-key (kbd "C-c +") 'ts-change-number)
  (global-set-key (kbd "C-c -") 'ts-change-number)
#+end_src

** Delete inside delimiters

#+begin_src emacs-lisp
  (defun ts-delete-inside-delimiters (arg)
    "Deletes the text within parentheses, brackets or quotes.
  With prefix ARG, delete delimiters too."
    (interactive "P")
    ;; Search for a match on the same line, don't delete across lines
    (search-backward-regexp "[[{(<\"\']" (line-beginning-position))
    (forward-char)
    (let ((lstart (point)))
      (search-forward-regexp "[]})>\"\']" (line-end-position))
      (backward-char)
      (if arg
          (kill-region (- lstart 1) (+ (point) 1))
        (kill-region lstart (point)))))

  (global-set-key (kbd "C-c d") 'ts-delete-inside-delimiters)
#+end_src

** Generate a numbered list

#+begin_src emacs-lisp
  (defun ts-generate-numbered-list (start end char)
    "Create a numbered list from START to END.  Using CHAR as punctuation."
    (interactive "nStart number:\nnEnd number:\nsCharacter:")
    (let ((x start))
      (while (<= x end)
        (insert (concat (number-to-string x) char))
        (newline)
        (setq x (+ x 1)))))
#+end_src

** Kill Region

#+begin_src emacs-lisp
  (defun ts-kill-region (arg)
    "Cut region or current ARG lines to kill ring."
    (interactive "p")
    (let (p1 p2)
      (if (use-region-p)
          (progn (setq p1 (region-beginning))
                 (setq p2 (region-end)))
        (progn (setq p1 (line-beginning-position))
               (setq p2 (line-beginning-position (+ arg 1)))))
      (kill-region p1 p2)))

  (global-set-key [remap kill-region] 'ts-kill-region)
#+end_src

** Kill Ring Save

#+begin_src emacs-lisp
  (defun ts-kill-ring-save (arg)
    "Copy region or current ARG lines to kill ring."
    (interactive "p")
    (let (p1 p2)
      (if (use-region-p)
          (progn (setq p1 (region-beginning))
                 (setq p2 (region-end)))
        (progn (setq p1 (line-beginning-position))
               (setq p2 (line-beginning-position (+ arg 1)))))
      (kill-ring-save p1 p2)
      (goto-char p2)))

  (global-set-key [remap kill-ring-save] 'ts-kill-ring-save)
#+end_src

** Kill Ring Save Whole Buffer

#+begin_src emacs-lisp
  (defun ts-kill-ring-save-whole-buffer ()
    "Save the entire contents of the buffer to the kill ring."
    (interactive)
    (kill-ring-save (point-min) (point-max))
    (message "Saved whole buffer to kill ring :-)"))

  (global-set-key (kbd "C-c h") 'ts-kill-ring-save-whole-buffer)
#+end_src

** Moving lines

#+begin_src emacs-lisp
  (defmacro save-column (&rest body)
    `(let ((column (current-column)))
       (unwind-protect (progn ,@body) (move-to-column column))))
  (put 'save-column 'lisp-indent-function 0)

  (defun move-line-up ()
    (interactive)
    (save-column (transpose-lines 1) (forward-line -2)))

  (defun move-line-down ()
    (interactive)
    (save-column (forward-line 1) (transpose-lines 1) (forward-line -1)))

  (global-set-key (kbd "M-p") 'move-line-up)
  (global-set-key (kbd "M-n") 'move-line-down)
#+end_src

** Sort Words

#+begin_src emacs-lisp
  (defun ts-sort-words (reverse beg end)
    "Sort words in region alphabetically, in REVERSE if negative.

  Prefixed with negative \\[universal-argument], sorts in reverse.

  The variable `sort-fold-case' determines whether alphabetic case
  affects the sort order.

  See `sort-regexp-fields'."
    (interactive "*P\nr")
    (sort-regexp-fields reverse "\\w+" "\\&" beg end))
#+end_src

** Surround stuff

#+begin_src emacs-lisp
  (defun ts-surround (begin end open close)
    "Put OPEN at BEGIN and CLOSE at END of the region.
  If you omit CLOSE, it will reuse OPEN, unless OPEN is a (,{,<,[,
  in which case CLOSE will be the matching pair."
    (interactive  "r\nsStart: \nsEnd: ")
    (save-excursion
      (goto-char end)
      (cond ((string= open "(") (insert ")"))
            ((string= open "[") (insert "]"))
            ((string= open "<") (insert ">"))
            ((string= open "{") (insert "}"))
            ((string= open "") (insert open))
            (t (insert close)))
      (goto-char begin)
      (insert open)))

  (global-set-key (kbd "M-s M-s") 'ts-surround)
#+end_src

** Untabify a buffer

#+begin_src emacs-lisp
  (defun ts-untabify-buffer ()
    "Convert all tabs to spaces in the buffer."
    (interactive)
    (untabify (point-min) (point-max)))
#+end_src

** XML pretty print

#+begin_src emacs-lisp
  (defun ts-xml-pretty-print ()
    "Reformat and indent XML."
    (interactive)
    (save-excursion
      (sgml-pretty-print (point-min) (point-max))
      (indent-region (point-min) (point-max))))
#+end_src

** COMMENT WSL Copy/Paste

For older versions of WSL. Deprecated for me now.

#+begin_src emacs-lisp :tangle (if (and operating-system-release (string-match "-[Mm]icrosoft" operating-system-release)) init-file "no")
  (defun ts-copy-to-windows-clipboard (start end)
    "Copy region to Window’s clipboard."
    (interactive "r")
    (shell-command-on-region start end "clip.exe")
    (deactivate-mark))

  (defalias 'ts-copy-to-windows-clipboard 'wsl-copy)
  (global-set-key (kbd "C-c C-w") 'ts-copy-to-windows-clipboard)

  (defun ts-paste-from-windows-clipboard ()
    "Paste from Window’s clipboard."
    (interactive)
    (let ((wslbuffername "wsl-temp-buffer"))
      (get-buffer-create wslbuffername)
      (with-current-buffer wslbuffername
        (insert (let ((coding-system-for-read 'dos))
                  ;; TODO: put stderr somewhere else
                  (shell-command
                   "powershell.exe -command ’Get-Clipboard’ 2> /dev/null"
                   wslbuffername nil))))
      (insert-buffer wslbuffername)
      (kill-buffer wslbuffername)))

  (defalias 'ts-paste-from-windows-clipboard 'wsl-paste)
  (global-set-key (kbd "C-c y") 'ts-paste-from-windows-clipboard)
#+end_src

** WSLg Copy Workaround

https://github.com/microsoft/wslg/issues/15
https://emacsredux.com/blog/2022/01/04/dealing-with-clipboard-issues-on-windows-11-wslg/

#+begin_src emacs-lisp :tangle (if (and operating-system-release (string-match "-[Mm]icrosoft" operating-system-release)) init-file "no")
  (defun ts-wslg-copy-workaround (start end)
    (interactive "r")
    (if (use-region-p)
        (let ((text (buffer-substring-no-properties start end)))
          (shell-command (concat "echo '" text "' | clip.exe")))))

  (global-set-key (kbd "C-c C-w") 'ts-wslg-copy-workaround)
#+end_src

** COMMENT Yank pop forwards (Emacs<28)

Don't bother tangling this if ~emacs-version~ > 28, as Emacs 28 has ~M-y~ bound
to completing read of the kill ring, making this pretty pointless.

#+begin_src emacs-lisp :tangle (if (version< emacs-version "28") init-file "no")
  (defun ts-yank-pop-forwards (arg)
    "Cycle forwards through the kill.  Reverse `yank-pop'.  With ARG."
    (interactive "p")
    (yank-pop (- arg)))

  (global-set-key (kbd "C-M-y") 'ts-yank-pop-forwards)
#+end_src

* File Functions
** Delete this file

#+begin_src emacs-lisp
  (defun ts-delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (or (buffer-file-name) (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
                               (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name) t)
      (kill-this-buffer)))

  (global-set-key (kbd "C-c f d") 'ts-delete-this-file)
#+end_src

** Insert other buffer file name

#+begin_src emacs-lisp
  (defun ts-insert-other-buffer-file-name (arg)
    "Does what it say on the the tin!
  With prefix ARG, omit path."
    (interactive "P")
    (insert (completing-read
             "Select Buffer Filename: "
             (delete nil
                     (mapcar (lambda (buffer)
                               (if (buffer-file-name buffer)
                                   (if arg
                                       (file-name-nondirectory
                                        (buffer-file-name buffer))
                                     (buffer-file-name buffer))))
                             (buffer-list))))))

  (global-set-key (kbd "C-c f i") 'ts-insert-other-buffer-file-name)
#+end_src

** Make backup of current file

#+begin_src emacs-lisp
  (defun ts-make-backup ()
    "Make a backup copy of current file or dired marked files.

  If in dired, backup current file or marked files."
    (interactive)
    (let (($fname (buffer-file-name)))
      (if $fname
          (let (($backup-name
                 (concat $fname "." (format-time-string "%y%m%d%H%M") ".bak")))
            (copy-file $fname $backup-name t)
            (message (concat "Backup saved at: " $backup-name)))
        (if (string-equal major-mode "dired-mode")
            (progn
              (mapc (lambda ($x)
                      (let (($backup-name
                             (concat $x "." (format-time-string "%y%m%d%H%M") ".bak")))
                        (copy-file $x $backup-name t)))
                    (dired-get-marked-files))
              (message "marked files backed up"))
          (user-error "Buffer not file nor dired")))))
#+end_src

#+begin_src emacs-lisp
  (defun ts-make-backup-and-save ()
    "Backup of current file and save, or backup dired marked files.
  For detail, see `ts-make-backup'."
    (interactive)
    (if (buffer-file-name)
        (progn
          (ts-make-backup)
          (when (buffer-modified-p)
            (save-buffer)))
      (progn
        (ts-make-backup))))

  (global-set-key (kbd "C-c f b") 'ts-make-backup-and-save)
#+end_src

** Open current file as root

#+begin_src emacs-lisp
  (defun ts-sudoedit (&optional arg)
    "Open current or ARG file as root."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (read-file-name "Find file (as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

  (global-set-key (kbd "C-c f s") 'ts-sudoedit)
#+end_src

** Rename file and buffer

#+begin_src emacs-lisp
  (defun ts-rename-this-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "FNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting a file!" name))
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (when (file-exists-p filename)
            (rename-file filename new-name 1))
          (rename-buffer new-name)
          (set-visited-file-name new-name)))))

  (global-set-key (kbd "C-c f r") 'ts-rename-this-file-and-buffer)
#+end_src

** Yank current file contents to kill ring

Very useful for copying ssh public keys...

#+begin_src emacs-lisp
  (defun ts-copy-file-contents-to-clipboard (file)
    "Copy a file's contents to the clipboard."
    (interactive "f")
    (with-current-buffer (find-file-noselect file)
      (kill-new (buffer-substring-no-properties (point-min) (point-max))))
    (message "Copied contents of %s to the clipboard" file))

  (global-set-key (kbd "C-c f h") 'ts-copy-file-contents-to-clipboard)
#+end_src

** Yank current file name to kill ring

#+begin_src emacs-lisp
  (defun ts-copy-file-name-to-clipboard (arg)
    "Copy the current buffer file name to the clipboard.
  With prefix ARG, omit path."
    (interactive "P")
    (let ((filename (if (equal major-mode 'dired-mode)
                        (if arg
                            (file-name-nondirectory
                             (directory-file-name
                              (file-name-directory default-directory)))
                          default-directory)
                      (if arg
                          (file-name-nondirectory buffer-file-name)
                        (buffer-file-name)))))
      (when filename
        (kill-new filename)
        (message "Copied '%s' to the clipboard." filename))))

  (global-set-key (kbd "C-c f w") 'ts-copy-file-name-to-clipboard)
#+end_src

* Miscellaneous
** Byte compile and load on save

#+begin_src emacs-lisp
  (defun ts-byte-compile-and-load ()
    "Byte compile Emacs Lisp files and load if ARG."
    (when (and buffer-file-name
               (equal (file-name-extension buffer-file-name) "el")
               (equal major-mode 'emacs-lisp-mode))
      (byte-compile-file buffer-file-name)
      (message "Compiled %s :-)" buffer-file-name)
      (load (file-name-sans-extension buffer-file-name))
      (message "Loaded %s :-)" buffer-file-name)))

  (add-hook 'after-save-hook 'ts-byte-compile-and-load)
#+end_src

** Ensure init files are byte compiled

This block will byte compile ~early-init.el~ and ~init.el~ if an existing
~.elc~ file is not up to date with their contents.

#+begin_src emacs-lisp
  (defun ts-ensure-byte-compiled-init ()
    "Run `byte-recompile-file' on config files with 'nil' FORCE and ARG 0.
  This means we don't compile if .elc is up to date but we always
  create a new .elc file if it doesn't already exist."
    (autoload 'byte-recompile-file "bytecomp")
    (if (file-readable-p (expand-file-name "early-init.el" user-emacs-directory))
        (byte-recompile-file (expand-file-name "early-init.el" user-emacs-directory) 'nil 0))
    (byte-recompile-file (expand-file-name "init.el" user-emacs-directory) 'nil 0))

  (add-hook 'after-init-hook 'ts-ensure-byte-compiled-init)
#+end_src
** Recompile config

#+begin_src emacs-lisp
  (defvar ts-files-to-recompile '("early-init.el" "init.el")
    "Files under `user-emacs-directory' that we use for configuration.")

  (defun ts-recompile-config ()
    "Recompile everything in Emacs configuration."
    (interactive)
    (mapc (lambda (file)
            (let ((path (expand-file-name file user-emacs-directory)))
              (when (file-readable-p path)
                (byte-recompile-file path t 0)
                (load (file-name-sans-extension path))
                (message "Re-compiled & loaded %s :-)" path))))
          ts-files-to-recompile))
#+end_src

** Tangle config

#+begin_src emacs-lisp
  (defun ts-tangle-config ()
    "Re-tangle my org mode configuration file."
    (interactive)
    (autoload 'org-babel-tangle-file "ob-tangle")
    (org-babel-tangle-file "~/src/emacs/README.org"))
#+end_src

** Googling

#+begin_src emacs-lisp
  (defun ts-google (arg)
    "Googles a query or region.  With prefix ARG, wrap in quotes."
    (interactive "P")
    (let ((query
           (if (region-active-p)
               (buffer-substring (region-beginning) (region-end))
             (read-string "Query: "))))
      (when arg (setq query (concat "\"" query "\"")))
      (browse-url
       (concat "http://www.google.com/search?ie=utf-8&oe=utf-8&q=" query))))

  (global-set-key (kbd "C-c M-s") 'ts-google)
#+end_src

** COMMENT Measure function executions

#+begin_src emacs-lisp
  (defmacro ts-measure-time (&rest body)
    "Measure the time it takes to evaluate BODY."
    `(let ((time (current-time)))
       ,@body
       (message "%.06f" (float-time (time-since time)))))
#+end_src

** Default Text Scale

#+begin_src emacs-lisp
  (defadvice text-scale-increase (around all-buffers (arg) activate)
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        ad-do-it)))
#+end_src

** COMMENT Registers

#+begin_src emacs-lisp
  (defun ts-jump-to-register-other-window ()
    "Tin job."
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (jump-to-register (register-read-with-preview "Jump to register")))

  (define-key ctl-x-4-map "j" 'ts-jump-to-register-other-window)
#+end_src

* Window Functions
** Better scrolling of other windows

This is better, since I don't need to send prefix to ~scroll-other-window~.

#+begin_src emacs-lisp
  (defun ts-scroll-other-window (arg)
    "Scroll up other window when called with prefix."
    (interactive "P")
    (if arg (scroll-other-window-down) (scroll-other-window)))

  (global-set-key [remap scroll-other-window] 'ts-scroll-other-window)
#+end_src

** Kill buffer other window

#+begin_src emacs-lisp
  (defun ts-kill-buffer-other-window ()
    "Kill the buffer in the last used window."
    (interactive)
    ;; Window selection is used because point goes to a different window if more
    ;; than 2 windows are present
    (let ((current-window (selected-window))
          (other-window (get-mru-window t t t)))
      (select-window other-window)
      (kill-this-buffer)
      (select-window current-window)))

  (global-set-key (kbd "C-c w k") 'ts-kill-buffer-other-window)
#+end_src

** Open a buffer in another window

#+begin_src emacs-lisp
  (defun ts-display-buffer-in-previous-window (buffer)
    "Display BUFFER in other window without switching to it."
    (interactive "BDisplay buffer in other window: ")
    (display-buffer buffer 'display-buffer-in-previous-window))

  (global-set-key (kbd "C-c w o") 'ts-display-buffer-in-previous-window)
#+end_src

** COMMENT Scroll lines down like Ctrl-y in Vim

#+begin_src emacs-lisp
  (defun ts-scroll-line-down (n)
    "Scroll line down N lines.  Ctrl-y in Vim."
    (interactive "p")
    (scroll-down n))

  (global-set-key (kbd "M-n") 'ts-scroll-line-down)
#+end_src

** COMMENT Scroll lines up like Ctrl-e in Vim

#+begin_src emacs-lisp
  (defun ts-scroll-line-up (n)
    "Scroll line up N lines.  Like Ctrl-e in Vim."
    (interactive "p")
    (scroll-up n))

  (global-set-key (kbd "M-p") 'ts-scroll-line-up)
#+end_src

** Split window right to last buffer

#+begin_src emacs-lisp
  (defun ts-split-window-right (prefix)
    "Split the window vertically and display the previous buffer.
  With PREFIX stay in current buffer."
    (interactive "p")
    (split-window-right)
    (other-window 1)
    (if (= prefix 1)
        (switch-to-next-buffer)))

  (global-set-key (kbd "C-c 3") 'ts-split-window-right)
#+end_src

** Split window below to last buffer

#+begin_src emacs-lisp
  (defun ts-split-window-below (prefix)
    "Split the window horizontally and display the previous buffer.
  With PREFIX stay in current buffer."
    (interactive "p")
    (split-window-below)
    (other-window 1)
    (if (= prefix 1)
        (switch-to-next-buffer)))

  (global-set-key (kbd "C-c 2") 'ts-split-window-below)
#+end_src

** Switch to the previous window

This is basically ~other-window~ backwards.

#+begin_src emacs-lisp
  (defun ts-prev-window ()
    "Go the previously used window, excluding other frames."
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-x O") 'ts-prev-window)
#+end_src

** Toggle focus to last window

#+begin_src emacs-lisp
  (defun ts-last-window ()
    "Switch back and forth between two windows easily."
    (interactive)
    (let ((win (get-mru-window t t t)))
      (unless win (error "Last window not found"))
      (let ((frame (window-frame win)))
        (raise-frame frame)
        (select-frame frame)
        (select-window win))))

  (global-set-key (kbd "C-c w w") 'ts-last-window)
#+end_src

** Toggle maximize window

#+begin_src emacs-lisp
  (defun ts-toggle-maximize-window ()
    "Temporarily maximize a window."
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (delete-other-windows))))

  (global-set-key (kbd "C-c z") 'ts-toggle-maximize-window)
#+end_src

** Toggle vertical -> horizontal splits

#+begin_src emacs-lisp
  (defun ts-toggle-split ()
    "Switch window split from horizontally to vertically.
  Or vice versa. Change right window to bottom, or change bottom
  window to right."
    (interactive)
    (autoload 'windmove-find-other-window "windmove" nil t)
    (let ((done))
      (dolist (dirs '((right . down) (down . right)))
        (unless done
          (let* ((win (selected-window))
                 (nextdir (car dirs))
                 (neighbour-dir (cdr dirs))
                 (next-win (windmove-find-other-window nextdir win))
                 (neighbour1 (windmove-find-other-window neighbour-dir win))
                 (neighbour2 (if next-win
                                 (with-selected-window next-win
                                   (windmove-find-other-window
                                    neighbour-dir next-win)))))
            (setq done (and (eq neighbour1 neighbour2)
                            (not (eq (minibuffer-window) next-win))))
            (if done
                (let* ((other-buf (window-buffer next-win)))
                  (delete-window next-win)
                  (if (eq nextdir 'right)
                      (split-window-vertically)
                    (split-window-horizontally))
                  (set-window-buffer
                   (windmove-find-other-window neighbour-dir)
                   other-buf))))))))

  (global-set-key (kbd "C-c w s") 'ts-toggle-split)
#+end_src

** COMMENT Transpose windows

#+begin_src emacs-lisp
  (defun ts-transpose-windows (arg)
    "Transpose windows.  Use prefix ARG to transpose in the other direction."
    (interactive "P")
    (if (not (> (count-windows) 1))
        (message "You can't rotate a single window!")
      (let* ((rotate-times (prefix-numeric-value arg))
             (direction (if (or (< rotate-times 0) (equal arg '(4)))
                            'reverse 'identity)))
        (dotimes (_ (abs rotate-times))
          (dotimes (i (- (count-windows) 1))
            (let* ((w1 (elt (funcall direction (window-list)) i))
                   (w2 (elt (funcall direction (window-list)) (+ i 1)))
                   (b1 (window-buffer w1))
                   (b2 (window-buffer w2))
                   (s1 (window-start w1))
                   (s2 (window-start w2))
                   (p1 (window-point w1))
                   (p2 (window-point w2)))
              (set-window-buffer-start-and-point w1 b2 s2 p2)
              (set-window-buffer-start-and-point w2 b1 s1 p1)))))))

  (define-key ctl-x-4-map "t" 'ts-transpose-windows)
#+end_src

* Emacs Packages
** Ansi Color

#+begin_src emacs-lisp
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
  (defun colorize-compilation-buffer ()
    "ANSI color in compilation buffer."
    (ansi-color-apply-on-region compilation-filter-start (point)))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

** Auto-fill

#+begin_src emacs-lisp
  (defun ts-fill-or-unfill ()
    "Like `fill-paragraph', but unfill if used twice."
    (interactive)
    (let ((fill-column
           (if (eq last-command 'ts-fill-or-unfill)
               (progn (setq this-command nil)
                      (point-max))
             fill-column)))
      (call-interactively #'fill-paragraph)))

  (defun ts-unfill-region (beg end)
    "Unfill the region from BEG to END.
  Joining text paragraphs into a single logical line. This is
  useful, e.g., for use with function `visual-line-mode'."
    (interactive "*r")
    (let ((fill-column (point-max)))
      (fill-region beg end)))

  (global-set-key [remap fill-paragraph] 'ts-fill-or-unfill)
  (global-set-key (kbd "C-M-q") 'ts-unfill-region)

  (setq-default fill-column 79)
  (add-hook 'org-mode-hook 'auto-fill-mode)
  (add-hook 'text-mode-hook 'auto-fill-mode)

  (global-set-key (kbd "C-c M-t a") 'toggle-text-mode-autofill)
#+end_src

** Auto-revert

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'global-auto-revert-mode) ;; reload if file changed on disk
#+end_src

** Battery

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'battery
    (setq battery-mode-line-format " [%b%p%%]")
    (setq battery-mode-line-limit 95)
    (setq battery-update-interval 180)
    (setq battery-load-low 20)
    (setq battery-load-critical 10))

  (add-hook 'after-init-hook 'display-battery-mode)
#+end_src

** Column Number

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'column-number-mode)
#+end_src

** Completion

Use funky new ~fido~ functionality for everything if we are on Emacs 27+.
Otherwise just use boring old ~ido~.

*** Icomplete

Turn on ~fido-mode~ at launch when we are Emacs 27+.

#+begin_src emacs-lisp
  (if (version< emacs-version "27")
      (add-hook 'after-init-hook 'icomplete-mode)
    (add-hook 'after-init-hook 'fido-mode))
#+end_src

**** Change completion styles

#+begin_src emacs-lisp
  (defun ts-icomplete-styles ()
    "Set icomplete styles based on Emacs version."
    (if (version< emacs-version "27")
        (setq-local completion-styles '(initials partial-completion substring basic))
      (setq-local completion-styles '(initials partial-completion flex substring basic))))
  (add-hook 'icomplete-minibuffer-setup-hook 'ts-icomplete-styles)
#+end_src

**** Icomplete keybindings

#+begin_src emacs-lisp
  (with-eval-after-load 'icomplete
    (unless (version< emacs-version "27")
      (define-key icomplete-minibuffer-map (kbd "C-j") 'icomplete-fido-exit))
    (define-key icomplete-minibuffer-map (kbd "M-j") 'exit-minibuffer)
    (define-key icomplete-minibuffer-map (kbd "C-n") 'icomplete-forward-completions)
    (define-key icomplete-minibuffer-map (kbd "C-p") 'icomplete-backward-completions)
    (define-key icomplete-minibuffer-map (kbd "C-s") 'icomplete-forward-completions)
    (define-key icomplete-minibuffer-map (kbd "C-r") 'icomplete-backward-completions)
    (define-key icomplete-minibuffer-map (kbd "<up>") 'icomplete-backward-completions)
    (define-key icomplete-minibuffer-map (kbd "<down>") 'icomplete-forward-completions)
    (define-key icomplete-minibuffer-map (kbd "<left>") 'icomplete-backward-completions)
    (define-key icomplete-minibuffer-map (kbd "<right>") 'icomplete-forward-completions))
#+end_src

**** Icomplete settings

#+begin_src emacs-lisp
  (with-eval-after-load 'icomplete
    (unless (version< emacs-version "28")
      (icomplete-vertical-mode))
    (setq icomplete-delay-completions-threshold 100)
    (setq icomplete-max-delay-chars 2)
    (setq icomplete-compute-delay 0.2)
    (setq icomplete-show-matches-on-no-input t)
    (setq icomplete-hide-common-prefix nil)
    (setq icomplete-prospects-height 1)
    ;; (setq icomplete-separator "\n")
    (setq icomplete-separator (propertize " · " 'face 'shadow))
    (setq icomplete-with-completion-tables t)
    (setq icomplete-tidy-shadowed-file-names t)
    (setq icomplete-in-buffer t))
#+end_src

*** Ido
**** Ido settings

#+begin_src emacs-lisp
  (setq ido-use-virtual-buffers 't) ;; show recent files too
  (setq ido-create-new-buffer 'always)
  (setq ido-enable-prefix t)
  (setq ido-enable-flex-matching 't)
  (setq ido-auto-merge-work-directories-length -1)
  (setq ido-use-filename-at-point 'nil)
  ;; vertical display
  (setq ido-decorations (quote ("\n--> "
                                " "
                                "\n    "
                                "\n    ..."
                                "["  "]"
                                "  [No match]"
                                "  [Matched]"
                                "  [Not readable]"
                                "  [Too big]"
                                "  [Confirm]")))
#+end_src

**** Ido M-x

Make ~M-x~ work as expected when ~ido-mode~ is enabled.

#+begin_src emacs-lisp
  (when (version< emacs-version "27")
    (with-eval-after-load 'ido
      (global-set-key
       "\M-x"
       (lambda ()
         (interactive)
         (call-interactively
          (intern
           (ido-completing-read
            "M-x "
            (all-completions "" obarray 'commandp))))))))
#+end_src

**** Ido keybindings

Add some custom keybindings in ~ido-mode~.

#+begin_src emacs-lisp
  (defun my/ido-keys ()
    "Custom ido keybindings."
    (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
    (define-key ido-completion-map (kbd "C-p") 'ido-prev-match)
    ;; stop ido suggestion when doing a save-as
    (define-key (cdr ido-minor-mode-map-entry) [remap write-file] nil))

  (add-hook 'ido-minibuffer-setup-hook (lambda () (set (make-local-variable 'truncate-lines) nil)))
  (add-hook 'ido-setup-hook (lambda () (define-key ido-completion-map [tab] 'ido-complete)))
  (add-hook 'ido-setup-hook 'my/ido-keys)
#+end_src

**** Turn on Ido and Ido Everywhere

Turn on ~ido-mode~ if we are on Emacs < 26.

#+begin_src emacs-lisp
  (when (version< emacs-version "27")
    (ido-mode t)
    (ido-everywhere t))
#+end_src

** Dabbrev

#+begin_src emacs-lisp
  (with-eval-after-load 'dabbrev
    (setq abbrev-file-name (concat user-emacs-directory "abbrevs"))
    (setq save-abbrevs 'silently)
    (unless (version< emacs-version "28")
      (setq abbrev-suggest t))
    (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
    (setq dabbrev-abbrev-skip-leading-regexp "[$*/=']")
    (setq dabbrev-backward-only nil)
    (setq dabbrev-case-distinction 'case-replace)
    (setq dabbrev-case-fold-search t)
    (setq dabbrev-case-replace 'case-replace)
    (setq dabbrev-check-other-buffers t)
    (setq dabbrev-eliminate-newlines t)
    (setq dabbrev-upcase-means-case-search t)
    (message "Lazy loaded dabbrev :-)"))
#+end_src

** Dired
*** Dired Extras

#+begin_src emacs-lisp
  (with-eval-after-load 'dired
    (defun ts-dired-get-size ()
      "Get cumlative size of marked or current item."
      (interactive)
      (let ((files (dired-get-marked-files)))
        (with-temp-buffer
          (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
          (message "Size of all marked files: %s"
                   (progn
                     (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
                     (match-string 1))))))

    (define-key dired-mode-map "?" 'ts-dired-get-size)

    (defun ts-dired-beginning-of-buffer ()
      "Go to first file in directory."
      (interactive)
      (goto-char (point-min))
      (dired-next-line 2))

    (define-key dired-mode-map [remap beginning-of-buffer] 'ts-dired-beginning-of-buffer)

    (defun ts-dired-end-of-buffer ()
      "Go to last file in directory."
      (interactive)
      (goto-char (point-max))
      (dired-next-line -1))

    (define-key dired-mode-map [remap end-of-buffer] 'ts-dired-end-of-buffer)

    (defun ts-dired-up-directory ()
      (interactive)
      (find-alternate-file ".."))

    (define-key dired-mode-map "b" 'ts-dired-up-directory))
#+end_src

*** Dired Omit

#+begin_src emacs-lisp
  (with-eval-after-load 'dired
    (autoload 'dired-omit-mode "dired-x" nil t)
    (autoload 'dired-omit-files "dired-x" nil t)
    (setq dired-omit-files "\\`[.]?#\\|\\`[.][.]?\\'\\|^\\..+$"))
#+end_src

*** Dired Listing Switches

#+begin_src emacs-lisp
  (with-eval-after-load 'dired
    (when (eq system-type 'berkeley-unix) (setq dired-listing-switches "-alhpL"))

    (when (eq system-type 'gnu/linux)
      (setq dired-listing-switches
            "-AGFhlv --group-directories-first --time-style=long-iso")))
#+end_src

*** Dired Settings

#+begin_src emacs-lisp
  (with-eval-after-load 'dired
    (setq dired-dwim-target t
          delete-by-moving-to-trash t
          dired-use-ls-dired nil
          dired-recursive-copies 'always
          dired-recursive-deletes 'always))
#+end_src

*** Dired Keybindings

#+begin_src emacs-lisp
  (with-eval-after-load 'dired
    (define-key dired-mode-map "f" 'dired-find-alternate-file)
    (define-key dired-mode-map "c" 'dired-do-compress-to)
    (define-key dired-mode-map ")" 'dired-omit-mode))
#+end_src

*** Dired AUX

#+begin_src emacs-lisp
  (with-eval-after-load 'dired-aux
    (setq dired-isearch-filenames 'dwim)
    ;; The following variables were introduced in Emacs 27.1
    (unless (version< emacs-version "27.1")
      (setq dired-create-destination-dirs 'ask)
      (setq dired-vc-rename-file t))
    (message "Lazy loaded dired-aux :-)"))
#+end_src

*** Dired-X Jump (Emacs<28)

Has to come outside of with-eval-after-load otherwise we have no dired-jump.

This is in ~dired~ not ~dired-jump~ in Emacs 28, which means we no longer have
to autoload these and bind the default keys prior to ~dired~ being loaded.

The default keys are ~C-x C-j~ and ~C-x 4 C-j~.

#+begin_src emacs-lisp :tangle (if (version< emacs-version "28") init-file "no")
  ;; This is in `dired' not `dired-jump' in Emacs 28
  (when (version< emacs-version "28")
    (autoload 'dired-jump "dired-x" nil t)
    (global-set-key (kbd "C-x C-j") 'dired-jump)
    (autoload 'dired-jump-other-window "dired-x" nil t)
    (define-key ctl-x-4-map "C-j" 'dired-jump-other-window))
#+end_src

*** Find Dired

#+begin_src emacs-lisp
  (with-eval-after-load 'find-dired
    ;; (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
    (setq find-ls-option
          '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
    (setq find-name-arg "-iname")
    (message "Lazy loaded find-dired :-)"))
#+end_src

*** Windows Find

First install GnuWin32 binaries from [[http://gnuwin32.sourceforge.net/packages.html][here]].

Or if you want all the GNU tools on your Windows box - use [[https://sourceforge.net/projects/getgnuwin32/files/getgnuwin32/][this]].

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) init-file "no")
  (setq find-program "C:/Program Files (x86)/GnuWin32/bin/find.exe")
  (setq grep-program "C:/Program Files (x86)/GnuWin32/bin/grep.exe")
  (setq xargs-program "C:/Program Files (x86)/GnuWin32/bin/xargs.exe")
#+end_src

*** Writeable Dired

#+begin_src emacs-lisp
  (with-eval-after-load 'wdired
    (setq wdired-allow-to-change-permissions t)
    (setq wdired-create-parent-directories t)
    (message "Lazy loaded wdired :-)"))
#+end_src

** Doc View

#+begin_src emacs-lisp
  (with-eval-after-load 'doc-view-mode
    (setq doc-view-continuous t)
    (setq doc-view-resolution 300)
    (message "Lazy loaded doc-view-mode :-)"))
#+end_src

** Ediff

#+begin_src emacs-lisp
  (with-eval-after-load 'ediff
    (setq ediff-diff-options "-w")
    (setq ediff-keep-variants nil)
    (setq ediff-make-buffers-readonly-at-startup nil)
    (setq ediff-merge-revisions-with-ancestor t)
    (setq ediff-show-clashes-only t)
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (add-hook 'ediff-after-quit-hook-internal 'winner-undo)

    ;; https://emacs.stackexchange.com/a/24602
    (defun disable-y-or-n-p (orig-fun &rest args)
      "Advise ORIG-FUN with ARGS so it dynamically rebinds `y-or-n-p'."
      (cl-letf (((symbol-function 'y-or-n-p) (lambda () t)))
        (apply orig-fun args)))

    (advice-add 'ediff-quit :around #'disable-y-or-n-p)
    (message "Lazy loaded ediff :-)"))
#+end_src

** Eldoc

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
  (add-hook 'lisp-mode-hook 'eldoc-mode)
#+end_src

** Electric

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'electric-indent-mode)
  ;; (add-hook 'text-mode-hook 'electric-quote-mode)
  (add-hook 'after-init-hook 'electric-pair-mode)
#+end_src

** ERC

#+begin_src emacs-lisp
  (with-eval-after-load 'erc
    (setq erc-autojoin-channels-alist '(("freenode.net" "#emacs")))
    (setq erc-fill-column 80)
    (setq erc-hide-list '("JOIN" "PART" "QUIT"))
    (setq erc-input-line-position -2)
    (setq erc-keywords '("knowayback"))
    (setq erc-nick "knowayback")
    (setq erc-prompt-for-password t)
    (setq erc-track-enable-keybindings t)
    (message "Lazy loaded erc :-)"))
#+end_src

** Eshell

#+begin_src emacs-lisp
  (with-eval-after-load 'eshell
    (defun ts-eshell-complete-recent-dir (&optional arg)
      "Switch to a recent `eshell' directory using completion.
  With \\[universal-argument] also open the directory in a `dired'
  buffer."
      (interactive "P")
      (let* ((dirs (ring-elements eshell-last-dir-ring))
             (dir (completing-read "Switch to recent dir: " dirs nil t)))
        (insert dir)
        (eshell-send-input)
        (when arg
          (dired dir))))

    (defun ts-eshell-complete-history ()
      "Insert element from `eshell' history using completion."
      (interactive)
      (let ((hist (ring-elements eshell-history-ring)))
        (insert
         (completing-read "Input history: " hist nil t))))

    (defun ts-eshell-prompt ()
      "Custom eshell prompt."
      (concat
       (propertize (user-login-name) 'face `(:foreground "green" ))
       (propertize "@" 'face `(:foreground "yellow"))
       (propertize (system-name) `face `(:foreground "green"))
       (propertize ":" 'face `(:foreground "yellow"))
       (if (string= (eshell/pwd) (getenv "HOME"))
           (propertize "~" 'face `(:foreground "magenta"))
         (propertize (eshell/basename (eshell/pwd)) 'face `(:foreground "magenta")))
       "\n"
       (if (= (user-uid) 0)
           (propertize "#" 'face `(:foreground "red"))
         (propertize "$" 'face `(:foreground "yellow")))
       (propertize " " 'face `(:foreground "white"))))

    ;; https://www.emacswiki.org/emacs/EshellPrompt
    (setq eshell-cd-on-directory t
          eshell-destroy-buffer-when-process-dies t
          eshell-highlight-prompt nil
          eshell-hist-ignoredups t
          eshell-history-size 4096
          eshell-ls-use-colors t
          eshell-prefer-lisp-functions t
          eshell-prefer-lisp-variables t
          eshell-prompt-regexp "^[^#$\n]*[#$] "
          eshell-prompt-function 'ts-eshell-prompt
          eshell-review-quick-commands nil
          eshell-save-history-on-exit t
          eshell-smart-space-goes-to-end t
          eshell-where-to-jump 'begin)

    (add-to-list 'eshell-modules-list 'eshell-tramp) ;; no sudo password with ~/.authinfo
    (add-hook 'eshell-preoutput-filter-functions 'ansi-color-apply)

    (defun ts-eshell-keys()
      (define-key eshell-mode-map (kbd "M-r") 'ts-eshell-complete-history)
      (define-key eshell-mode-map (kbd "C-=") 'ts-eshell-complete-recent-dir))

    (add-hook 'eshell-mode-hook 'ts-eshell-keys)
    (message "Lazy loaded eshell :-)"))
#+end_src

#+begin_src emacs-lisp
  (defun ts-eshell-other-window ()
    "Open an `eshell' in another window."
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (eshell))

  (autoload 'eshell "eshell" nil t)
  (global-set-key (kbd "C-c e") 'eshell)
  (global-set-key (kbd "C-c 4 e") 'ts-eshell-other-window)
#+end_src

** Flymake

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'flymake-mode)
#+end_src

** Flyspell

Don't bother using this on Windows as I can rather be bothered to install
[[http://aspell.net/win32/][Aspell]] for Windows.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (unless (eq system-type 'windows-nt)
    (add-hook 'text-mode-hook 'flyspell-mode)
    (add-hook 'org-mode-hook 'flyspell-mode)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))
#+end_src

** COMMENT Fringe

#+begin_src emacs-lisp
  (fringe-mode nil)
  (setq-default fringes-outside-margins nil)
  (setq-default indicate-buffer-boundaries nil)
  (setq-default indicate-empty-lines nil)
  (setq-default overflow-newline-into-fringe t)
#+end_src

** Gnus

#+begin_src emacs-lisp
  (with-eval-after-load 'gnus
    (setq gnus-init-file "~/.emacs.d/init.el")
    (setq gnus-home-directory "~/.emacs.d/")
    (setq message-directory "~/.emacs.d/mail")
    (setq gnus-directory "~/.emacs.d/news")
    (setq nnfolder-directory "~/.emacs.d/mail/archive")
    (setq gnus-use-full-window nil)
    (setq gnus-select-method '(nntp "news.gwene.org"))
    ;; (setq gnus-secondary-select-methods '((nntp "news.gnus.org")))
    (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)
    (setq gnus-thread-hide-subtree t)
    (setq gnus-thread-ignore-subject t)
    (message "Lazy loaded gnus :-)"))
#+end_src

** Hide/Show

#+begin_src emacs-lisp
  (add-hook 'shell-script-mode-hook 'hs-minor-mode)
  (add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

** Highlight changes

#+begin_src emacs-lisp
  (setq highlight-changes-visibility-initial-state nil)
  (global-set-key (kbd "C-c n") 'highlight-changes-next-change)
  (global-set-key (kbd "C-c p") 'highlight-changes-previous-change)
  (add-hook 'emacs-startup-hook 'global-highlight-changes-mode)
#+end_src

** Highlight line

#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'hl-line-mode)
  (add-hook 'org-mode-hook 'hl-line-mode)
  (add-hook 'prog-mode-hook 'hl-line-mode)
  (add-hook 'shell-script-mode-hook 'hl-line-mode)
  (add-hook 'text-mode-hook 'hl-line-mode)
#+end_src

** Hippie Expand

#+begin_src emacs-lisp
  (defun ts-hippie-expand-completions (&optional hippie-expand-function)
    "Return the full list of completions generated by HIPPIE-EXPAND-FUNCTION.
  The optional argument can be generated with `make-hippie-expand-function'."
    (let ((this-command 'ts-hippie-expand-completions)
          (last-command last-command)
          (buffer-modified (buffer-modified-p))
          (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
      (cl-flet ((ding)) ; avoid the (ding) when hippie-expand exhausts its options.
        (while (progn
                 (funcall hippie-expand-function nil)
                 (setq last-command 'ts-hippie-expand-completions)
                 (not (equal he-num -1)))))
      ;; Evaluating the completions modifies the buffer, however we will finish
      ;; up in the same state that we began.
      (set-buffer-modified-p buffer-modified)
      ;; Provide the options in the order in which they are normally generated.
      (delete he-search-string (reverse he-tried-table))))

  (defun ts-hippie-complete-with (hippie-expand-function)
    "Offer `completing-read' using the specified HIPPIE-EXPAND-FUNCTION."
    (let* ((options (ts-hippie-expand-completions hippie-expand-function))
           (selection (and options (completing-read "Completions: " options))))
      (if selection
          (he-substitute-string selection t)
        (message "No expansion found"))))

  (defun ts-hippie-expand-completing-read ()
    "Offer `completing-read' for the word at point."
    (interactive)
    (ts-hippie-complete-with 'hippie-expand))

  (global-set-key (kbd "M-/") 'hippie-expand)
  (global-set-key (kbd "C-M-/") 'ts-hippie-expand-completing-read)
#+end_src

** Imenu

#+begin_src emacs-lisp
  (with-eval-after-load 'imenu
    (setq imenu-auto-rescan t)
    (setq imenu-auto-rescan-maxout 600000)
    (setq imenu-eager-completion-buffer t)
    (setq imenu-level-separator "/")
    (setq imenu-max-item-length 100)
    (setq imenu-space-replacement " ")
    (setq imenu-use-markers t)
    (setq imenu-use-popup-menu nil)
    (message "Lazy loaded imenu :-)"))

  (autoload 'imenu "imenu" nil t)
  (global-set-key (kbd "C-c i") 'imenu)
#+end_src

** Isearch
*** Isearch exit

#+begin_src emacs-lisp
  (defun ts-isearch-exit ()
    "Move point to the start of the matched string."
    (interactive)
    (when (eq isearch-forward t)
      (goto-char isearch-other-end))
    (isearch-exit))

  (define-key isearch-mode-map (kbd "RET") 'ts-isearch-exit)
#+end_src

*** Copy to isearch

#+begin_src emacs-lisp
  (defun ts-copy-to-isearch ()
    "Copy up to the search match when searching forward.

  When searching backward, copy to the start of the search match."
    (interactive)
    (ts-isearch-exit)
    (call-interactively 'kill-ring-save)
    (exchange-point-and-mark))

  (define-key isearch-mode-map (kbd "M-w") 'ts-copy-to-isearch)
#+end_src

*** Kill to isearch

#+begin_src emacs-lisp
  (defun ts-kill-to-isearch ()
    "Kill up to the search match when searching forward.

  When searching backward, kill to the beginning of the match."
    (interactive)
    (ts-isearch-exit)
    (call-interactively 'kill-region))

  (define-key isearch-mode-map (kbd "C-k") 'ts-kill-to-isearch)
#+end_src

*** Isearch Abort DWIM

#+begin_src emacs-lisp
  (defun ts-isearch-abort-dwim ()
    "Delete failed `isearch' input, single char, or cancel search.

  This is a modified variant of `isearch-abort' that allows us to
  perform the following, based on the specifics of the case: (i)
  delete the entirety of a non-matching part, when present; (ii)
  delete a single character, when possible; (iii) exit current
  search if no character is present and go back to point where the
  search started."
    (interactive)
    (if (eq (length isearch-string) 0)
        (isearch-cancel)
      (isearch-del-char)
      (while (or (not isearch-success) isearch-error)
        (isearch-pop-state)))
    (isearch-update))

  (define-key isearch-mode-map (kbd "<backspace>") 'ts-isearch-abort-dwim)
#+end_src

*** Keybindings

#+begin_src emacs-lisp
  (define-key isearch-mode-map (kbd "M-/") 'isearch-complete)
  (define-key minibuffer-local-isearch-map (kbd "M-/") 'isearch-complete-edit)
#+end_src

#+begin_src emacs-lisp
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "M-s b") 'multi-isearch-buffers-regexp)
  (global-set-key (kbd "M-s f") 'multi-isearch-files-regexp)
  (global-set-key (kbd "M-s M-o") 'multi-occur)
#+end_src

*** Settings

Don't tangle this on ~emacs-version~ < 27

#+begin_src emacs-lisp :tangle (if (version< emacs-version "27.1") "no" init-file)
  (unless (version< emacs-version "27.1")
    (setq isearch-allow-scroll 'unlimited)
    (setq isearch-yank-on-move 'shift)
    (setq isearch-lazy-count t)
    (setq lazy-count-suffix-format " (%s/%s)"))
#+end_src

** Line Numbers

#+begin_src emacs-lisp
  (setq display-line-numbers 'relative)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'sh-script-hook 'display-line-numbers-mode)
#+end_src

** Minibuffer
*** Completion framework settings

#+begin_src emacs-lisp
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-ignore-case t)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completions-detailed t)
  (setq completions-format 'one-column)
#+end_src

*** Misc Minibuffer settings

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
  (setq file-name-shadow-mode 1)
  (setq minibuffer-depth-indicate-mode 1)
  (setq minibuffer-eldef-shorten-default t)
  (setq minibuffer-electric-default-mode 1)
  (setq read-answer-short t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq resize-mini-windows t)
#+end_src

It may also be wise to raise gc-cons-threshold while the minibuffer is active,
so the GC doesn’t slow down expensive commands (or completion frameworks, like
helm and ivy). Stolen from [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][Doom Emacs FAQ]].

#+begin_src emacs-lisp
  (add-hook 'minibuffer-setup-hook (lambda () (setq gc-cons-threshold most-positive-fixnum)))
  (add-hook 'minibuffer-exit-hook (lambda () (setq gc-cons-threshold 16777216))) ; 16mb
#+end_src

*** Save history mode

#+begin_src emacs-lisp
  (with-eval-after-load 'savehist
    (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
    (setq savehist-save-minibuffer-history 1)
    (message "Lazy loaded savehist :-)"))
  (add-hook 'emacs-startup-hook 'savehist-mode)
#+end_src

** Occur

#+begin_src emacs-lisp
  (add-hook 'occur-mode-hook 'hl-line-mode)
  (define-key occur-mode-map "t" 'toggle-truncate-lines)
#+end_src

** Org
*** Org Babel Load Languages

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (defadvice org-babel-execute-src-block (around load-language nil activate)
      "Load language if needed"
      (let ((language (org-element-property :language (org-element-at-point))))
        (unless (cdr (assoc (intern language) org-babel-load-languages))
          (add-to-list 'org-babel-load-languages (cons (intern language) t))
          (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
        ad-do-it)))
#+end_src

No need to tangle, when using the advice above, leaving here for reference.

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((awk . t)
       (C . t)
       (clojure . t)
       (css . t)
       (dot . t) ;; graphviz language
       (emacs-lisp . t)
       (gnuplot . t)
       (haskell . t)
       ;; (http . t)
       (java . t)
       (js . t)
       (latex . t)
       (lisp . t)
       (makefile . t)
       (ocaml . t)
       (perl . t)
       (python . t)
       (plantuml . t)
       (ruby . t)
       (scheme . t)
       (sed . t)
       (shell . t)
       (sql . t)
       (sqlite . t))))
#+end_src
*** Org Capture Templates

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-capture-templates
          '(("t" "TODO Entry" entry (file+headline "~/org/todo.org" "Captured")
             "* TODO %?\n  %i\n  %a")
            ("j" "Journal Entry" entry (file+datetree "~/org/journal.org" "Captured")
             "* %?\nEntered on %U\n %i\n  %a")
            ("n" "Notes Entry" entry (file+datetree "~/org/notes.org" "Captured")
             "* %?\nEntered on %U\n %i\n  %a"))))
#+end_src

*** Org Export & View HTML

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (defun ts-org-export-to-html-and-browse ()
      "Export org file to html and browse-url-of-file"
      (interactive)
      (browse-url-of-file (org-html-export-to-html)))
    (define-key org-mode-map (kbd "C-x M-b") 'ts-org-export-to-html-and-browse))
#+end_src

*** Org Global Keybindings

#+begin_src emacs-lisp
  (autoload 'org-mode "org" nil t)
  (autoload 'org-agenda "org" nil t)
  (global-set-key (kbd "C-c o a") 'org-agenda)
  (autoload 'org-capture "org" nil t)
  (global-set-key (kbd "C-c o c") 'org-capture)
  (autoload 'org-store-link "org" nil t)
  (global-set-key (kbd "C-c o l") 'org-store-link)
  (autoload 'org-time-stamp "org" nil t)
  (global-set-key (kbd "C-c o t") 'org-time-stamp)
#+end_src

*** Org Latex

#+begin_src emacs-lisp
  (with-eval-after-load 'org-latex
    (setq org-latex-listings 'minted)
    (setq org-latex-pdf-process
          '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (add-to-list 'org-latex-packages-alist '("" "minted")))
#+end_src

*** Org Misc Settings

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-startup-folded t) ; start in overview mode
    (setq org-directory "~/org")
    (setq org-agenda-files (file-expand-wildcards "~/org/*.org"))
    (setq org-default-notes-file "~/org/notes.org")
    (setq org-image-actual-width nil) ; try to get width from #+ATTR.* keyword
    (setf org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))
    (setq org-emphasis-regexp-components '(" \t('\"{" "- \t.,:!?;'\")}\\" " \t\r\n,\"'" "." 300))
    (setq org-confirm-babel-evaluate t)
    (setq org-export-with-toc t)
    (setq org-indent-indentation-per-level 1)
    (setq org-list-allow-alphabetical t)
    (setq org-list-indent-offset 1)
    (setq org-return-follows-link t)
    (setq org-startup-indented t)
    (setq org-html-validation-link nil) ; don't add "validate" postamble
    (setq org-use-fast-todo-selection t))
#+end_src

*** COMMENT Org Narrow to Parent

#+begin_src emacs-lisp
  (defun ts-org-narrow-to-parent ()
    "Narrow buffer to the current subtree."
    (interactive)
    (widen)
    (org-up-element)
    (save-excursion
      (save-match-data
        (org-with-limited-levels
         (narrow-to-region
          (progn
            (org-back-to-heading t) (point))
          (progn (org-end-of-subtree t t)
                 (when (and (org-at-heading-p) (not (eobp)))
                   (backward-char 1))
                 (point)))))))

  (define-key org-mode-map (kbd "C-c M-p") 'ts-org-narrow-to-parent)
#+end_src

*** Org Outline/Goto

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-goto-interface 'outline-path-completionp)
    (setq org-outline-path-complete-in-steps nil)
    ;; org-goto is basically imenu on steroids for org-mode
    (define-key org-mode-map (kbd "C-c i") 'org-goto))
#+end_src

*** Org Recompile Post Tangle

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (cond ((version= emacs-version "27")
           (progn
             (add-hook 'org-babel-post-tangle-hook (lambda () (byte-recompile-file early-init nil 0 t)))
             (add-hook 'org-babel-post-tangle-hook (lambda () (byte-recompile-file init-file nil 0 t)))))
          ((version= emacs-version "28")
           (progn
             (add-hook 'org-babel-post-tangle-hook (lambda () (byte-recompile-file early-init nil 0)))
             (add-hook 'org-babel-post-tangle-hook 'emacs-lisp-byte-compile-and-load)))
          (t (add-hook 'org-babel-post-tangle-hook 'emacs-lisp-byte-compile-and-load))))
#+end_src

*** Org Recursive Sort

#+begin_src emacs-lisp
  (defun ts-org-recursive-sort ()
    "Sort all entries in the current buffer, recursively."
    (interactive)
    (org-map-entries (lambda ()
                       (condition-case x
                           (org-sort-entries nil ?a) (user-error)))))
#+end_src

*** Org Refile

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-refile-use-outline-path 'file)
    (setq org-refile-allow-creating-parent-nodes 'confirm)
    (setq org-refile-targets '((nil :maxlevel . 9))))
#+end_src

*** Org Special Keys

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-special-ctrl-a/e 'reversed)
    (setq org-special-ctrl-k t)
    (setq org-special-ctrl-o t))
#+end_src

*** Org Speed Commands

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-use-speed-commands t)
    (setq org-speed-commands-user
          '(("N" . org-down-element)
            ("P" . org-up-element))))
#+end_src

*** Org Src

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-src-window-setup 'current-window))
#+end_src

*** Org Structure Templates

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (if (not (version< emacs-version "27")) (require 'org-tempo))
    (setq org-structure-template-alist (append org-structure-template-alist
                                               '(("cl" . "src common-lisp")
                                                 ("el" . "src emacs-lisp")
                                                 ("go" . "src go")
                                                 ("ja" . "src java")
                                                 ("js" . "src javascript")
                                                 ("kr" . "src c")
                                                 ("py" . "src python")
                                                 ("sh" . "src shell")
                                                 ("sq" . "src sql")
                                                 ("tx" . "src text")))))
#+end_src

*** Org Todo Keywords

Add =!= in the sequence parens to insert timestamps and add =@= to require a
message.

#+begin_quote
Since it is normally too much to record a note for every state, Org mode
expects configuration on a per-keyword basis for this. This is achieved by
adding special markers ‘!’ (for a timestamp) or ‘@’ (for a note with timestamp)
in parentheses after each keyword.
#+end_quote

https://orgmode.org/manual/Tracking-TODO-state-changes.html

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-todo-keywords '((sequence
                               "TODO(t)"
                               "IN-PROGRESS(i)"
                               "BLOCKED(b)"
                               "DONE(d)"
                               ))))
#+end_src

** Pending delete

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'pending-delete-mode 1) ;; remove selected region if typing
#+end_src

** Prettify Symbols

#+begin_src emacs-lisp
  (with-eval-after-load 'prettify-symbols
    (setq prettify-symbols-unprettify-at-point 'right-edge)
    (message "Lazy loaded prettify-symbols :-)"))
  (add-hook 'emacs-startup-hook 'global-prettify-symbols-mode)
#+end_src

** Project (Emacs 28+)

We only tangle this when ~emacs-version~ > 28, since it's not very useful prior
to that.

#+begin_src emacs-lisp :tangle (if (version< emacs-version "28") "no" init-file)
  (setq ts-project-roots '("~/src"))

  (defun ts-project--git-repo-p (directory)
    "Return non-nil if there is a git repository in DIRECTORY."
    (and
     (file-directory-p (concat directory "/.git"))
     (file-directory-p (concat directory "/.git/info"))
     (file-directory-p (concat directory "/.git/objects"))
     (file-directory-p (concat directory "/.git/refs"))
     (file-regular-p (concat directory "/.git/HEAD"))))

  (defun ts-project--git-repos-recursive (directory maxdepth)
    "List git repos in under DIRECTORY recursively to MAXDEPTH."
    (let* ((git-repos '())
           (current-directory-list
            (directory-files directory t directory-files-no-dot-files-regexp)))
      ;; while we are in the current directory
      (if (ts-project--git-repo-p directory)
          (setq git-repos (cons (file-truename (expand-file-name directory)) git-repos)))
      (while current-directory-list
        (let ((f (car current-directory-list)))
          (cond ((and (file-directory-p f)
                      (file-readable-p f)
                      (> maxdepth 0)
                      (not (ts-project--git-repo-p f)))
                 (setq git-repos
                       (append git-repos
                               (ts-project--git-repos-recursive f (- maxdepth 1)))))
                ((ts-project--git-repo-p f)
                 (setq git-repos (cons
                                  (file-truename (expand-file-name f)) git-repos))))
          (setq current-directory-list (cdr current-directory-list))))
      (delete-dups git-repos)))

  (defun ts-project--list-projects ()
    "Produce list of projects in `ts-project-roots'."
    (let ((cands (delete-dups (mapcan (lambda (directory)
                                        (ts-project--git-repos-recursive
                                         (expand-file-name directory)
                                         10))
                                      ts-project-roots))))
      ;; needs to be a list of lists
      (mapcar (lambda (d)
                (list (abbreviate-file-name d)))
              cands)))

  (defun ts-project-update-projects ()
    "Overwrite `project--list' using `ts-project--list-projects'.
      WARNING: This will destroy & replace the contents of `project-list-file'."
    (interactive)
    (autoload 'project--ensure-read-project-list "project" nil t)
    (project--ensure-read-project-list)
    (setq project--list (ts-project--list-projects))
    (project--write-project-list)
    (message "Updated project list in %s" project-list-file))

  ;; (add-hook 'emacs-startup-hook 'ts-project-update-projects)
  (global-set-key (kbd "C-x p u") 'ts-project-update-projects)
#+end_src

#+begin_src emacs-lisp :tangle (if (version< emacs-version "28") "no" init-file)
  (with-eval-after-load 'project
    (setq project-switch-commands
          '((?b "Buffer" project-switch-to-buffer)
            (?c "Compile" project-compile)
            (?d "Dired" project-dired)
            (?e "Eshell" project-eshell)
            (?f "File" project-find-file)
            (?g "Grep" project-find-regexp)
            (?q "Query replace" project-query-replace-regexp)
            (?r "Run command" project-async-shell-command)
            (?s "Search" project-search)
            (?v "VC dir" project-vc-dir)))
    (message "Lazy loaded project :-)"))
#+end_src

** Pulse

https://karthinks.com/software/batteries-included-with-emacs/

#+begin_src emacs-lisp
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (dolist (command '(scroll-up-command scroll-down-command
                                       recenter-top-bottom other-window))
    (advice-add command :after #'pulse-line))
#+end_src

** Python

#+begin_src emacs-lisp
  (with-eval-after-load 'python
    ;; (when (eq system-type 'windows-nt)
    ;;   (setq exec-path
    ;;         (append exec-path
    ;;                 '("C:/Users/Toby/AppData/Local/Programs/Python/Python310")))
    ;;   (setq python-shell-interpreter
    ;;         "C:/Users/Toby/AppData/Local/Programs/Python/Python310"))
    (setq python-fill-docstring-style 'django)
    (message "Lazy loaded python :-)"))
#+end_src

** Recentf

#+begin_src emacs-lisp
  (with-eval-after-load 'recentf
    (setq recentf-exclude '(".gz"
                            ".xz"
                            ".zip"
                            "/elpa/"
                            "/ssh:"
                            "/sudo:"
                            "^/var/folders\\.*"
                            "COMMIT_EDITMSG\\'"
                            ".*-autoloads\\.el\\'"
                            "[/\\]\\.elpa/"))
    (setq recentf-max-menu-items 128)
    (setq recentf-max-saved-items 256)

    (defun ts--recentf-get-paths ()
      "Return de-duplicated and abbreviated `recentf-list'."
      (delete-dups (mapcar 'abbreviate-file-name recentf-list)))

    (defun ts-recentf-find-file ()
      "`find-file' using `recentf-list'."
      (interactive)
      (find-file (completing-read "Find file: " (ts--recentf-get-paths))))
    (global-set-key (kbd "C-c r") 'ts-recentf-find-file)

    (defun ts-recentf-find-file-other-window ()
      "`find-file' using `recentf-list'."
      (interactive)
      (find-file-other-window
       (completing-read "Find file in other window: " (ts--recentf-get-paths))))
    (global-set-key (kbd "C-c 4 r") 'ts-recentf-find-file-other-window)

    (defun ts-recentf-find-file-other-frame ()
      "`find-file' using `recentf-list'."
      (interactive)
      (find-file-other-frame
       (completing-read "Find file in other frame: " (ts--recentf-get-paths))))
    (global-set-key (kbd "C-c 5 r") 'ts-recentf-find-file-other-frame)

    (message "Lazy loaded recentf :-)"))

  (global-set-key (kbd "C-c C-r") 'recentf-open-files)
  (add-hook 'emacs-startup-hook 'recentf-mode)
#+end_src
** Repeat Mode

Emacs 28+

https://karthinks.com/software/it-bears-repeating/

#+begin_src emacs-lisp :tangle (if (version< emacs-version "28") "no" init-file)
  (defvar isearch-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "s") #'isearch-repeat-forward)
      (define-key map (kbd "r") #'isearch-repeat-backward)
      map))

  (dolist (cmd '(isearch-repeat-forward isearch-repeat-backward))
    (put cmd 'repeat-map 'isearch-repeat-map))

  (repeat-mode)
#+end_src

** Saveplace

#+begin_src emacs-lisp
  (with-eval-after-load 'save-place
    (setq save-place-file (concat user-emacs-directory "saveplace.el"))
    (message "Lazy loaded save-place-mode :-)"))
  (add-hook 'emacs-startup-hook 'save-place-mode)
#+end_src

** Selective Display

#+begin_src emacs-lisp
  (defun ts-toggle-selective-display ()
    "Toggle `selective-display'."
    (interactive)
    (if selective-display
        (setq-local selective-display nil)
      (setq-local selective-display 1)))

  (global-set-key (kbd "C-x $") 'ts-toggle-selective-display)
#+end_src

** Semantic

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'semantic-mode)
#+end_src

** Shell

#+begin_src emacs-lisp
  (with-eval-after-load 'shell
    (setq ansi-color-for-comint-mode t)
    (unless (version< emacs-version "27")
      ;; show current directory when prompting for a shell command.
      (setq shell-command-prompt-show-cwd t)))
#+end_src

** Shell Script

#+begin_src emacs-lisp
  (setq auto-mode-alist (append auto-mode-alist
                                '(("\\.sh\\'" . shell-script-mode)
                                  ("\\.bash.*\\'" . shell-script-mode)
                                  ("\\.zsh.*\\'" . shell-script-mode)
                                  ("\\.aliases\\'" . shell-script-mode)
                                  ("\\.functions\\'" . shell-script-mode)
                                  ("\\bashrc\\'" . shell-script-mode)
                                  ("\\kshrc\\'" . shell-script-mode)
                                  ("\\profile\\'" . shell-script-mode)
                                  ("\\zshenv\\'" . shell-script-mode)
                                  ("\\zprompt\\'" . shell-script-mode)
                                  ("\\zshrc\\'" . shell-script-mode)
                                  ("\\prompt_.*_setup\\'" . shell-script-mode))))

  (setq interpreter-mode-alist (append interpreter-mode-alist
                                       '(("bash" . shell-script-mode)
                                         ("ksh" . shell-script-mode)
                                         ("sh" . shell-script-mode)
                                         ("zsh" . shell-script-mode))))

  (with-eval-after-load 'sh-script
    (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
    (message "Lazy loaded shell-script-mode :-)"))
#+end_src

** Show paren

#+begin_src emacs-lisp
  (with-eval-after-load 'paren
    (setq show-paren-when-point-in-periphery t)
    (setq show-paren-when-point-inside-paren t))
  (add-hook 'after-init-hook 'show-paren-mode)
#+end_src

** Size Indication

#+begin_src emacs-lisp :tangle no
  (add-hook 'after-init-hook 'size-indication-mode)
#+end_src

** Subword

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'global-subword-mode) ;; move by camel case, etc
#+end_src

** Tab-bar (Emacs 27+)

Don't tangle this block on ~emacs-version~ < 27.

#+begin_src emacs-lisp :tangle (if (version< emacs-version "27") "no" init-file)
  (defun ts-tab-bar-select-dwim ()
    "Do-What-I-Mean function for getting to a `tab-bar-mode' tab.
  If no other tab exists, create one and switch to it. If there is
  one other tab (so two in total) switch to it without further
  questions. Else use completion to select the tab to switch to."
    (interactive)
    (let ((tabs (mapcar (lambda (tab)
                          (alist-get 'name tab))
                        (tab-bar--tabs-recent))))
      (cond ((eq tabs nil)
             (tab-new))
            ((eq (length tabs) 1)
             (tab-next))
            (t
             (tab-bar-switch-to-tab
              (completing-read "Select tab: " tabs nil t))))))

  (global-set-key (kbd "C-x t t") 'ts-tab-bar-select-dwim)

  (with-eval-after-load 'tab-bar-mode
    (setq tab-bar-close-button-show nil)
    (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
    ;; (setq tab-bar-show nil)
    ;; (setq tab-bar-tab-hints t)
    ;; (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
    (tab-bar-history-mode 1))
#+end_src

** Term
*** ANSI Term launcher

#+begin_src emacs-lisp
  (defun ts-ansi-term ()
    "Opens shell from $SHELL environmental variable in `ansi-term'."
    (interactive)
    ;; https://emacs.stackexchange.com/a/48481
    (let ((switch-to-buffer-obey-display-actions))
      (ansi-term (getenv "SHELL"))))

  (global-set-key (kbd "C-c tt") 'ts-ansi-term)

  (defun ts-ansi-term-other-window ()
    "Opens default $SHELL `ansi-term' in another window."
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (ts-ansi-term))

  (global-set-key (kbd "C-c 4 tt") 'ts-ansi-term-other-window)
#+end_src

*** Set term coding system to UTF-8

#+begin_src emacs-lisp
  (add-hook 'term-exec (lambda () (set-process-coding-system 'utf-8-unix 'utf-8-unix)))
#+end_src

*** Switch to ANSI Term

#+begin_src emacs-lisp
  (defun ts-switch-to-ansi-term ()
    "Open an `ansi-term' if it doesn't already exist.
  Otherwise switch to current one."
    (interactive)
    (if (get-buffer "*ansi-term*")
        (switch-to-buffer "*ansi-term*")
      (ansi-term (getenv "SHELL"))))

  (global-set-key (kbd "C-c ts") 'ts-switch-to-ansi-term)

  (defun ts-switch-to-ansi-term-other-window()
    "Does what it states on the tin!"
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (ts-switch-to-ansi-term))

  (global-set-key (kbd "C-c 4 ts") 'ts-switch-to-ansi-term-other-window)
#+end_src

*** Term Advise

#+begin_src emacs-lisp
  (with-eval-after-load 'term
    (defadvice term-handle-exit (after term-kill-buffer-on-exit activate)
      "Kill term when shell exits."
      (kill-buffer))
    (setq term-buffer-maximum-size 200000)
    (message "Lazy loaded term :-)"))
#+end_src

** Time

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'time
    (setq display-time-format "%H:%M %d/%m")
    (setq display-time-default-load-average 'nil))

  (add-hook 'after-init-hook 'display-time-mode)
#+end_src

** Tramp

#+begin_src emacs-lisp
  (with-eval-after-load 'tramp
    (setq tramp-backup-directory-alist backup-directory-alist)
    (setq tramp-default-method "ssh")
    (setf tramp-persistency-file-name (concat temporary-file-directory "tramp-" (user-login-name)))
    (message "Lazy loaded tramp :-)"))
#+end_src

** Version Control

[[https://protesilaos.com/dotemacs/#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Protesilaos Stavrou's VC reference]]

#+begin_src emacs-lisp
  (with-eval-after-load 'vc
    (setq vc-follow-symlinks t)
    (setq vc-make-backup-files t)
    (setq version-control t)
    (message "Lazy loaded vc :-)"))

  (defun ts-vc-dir (&optional arg)
    "Run `vc-dir' for the current project or directory.
  With optional ARG (\\[universal-argument]), use the present
  working directory, else default to the root of the current
  project, as defined by `vc-root-dir'."
    (interactive "P")
    (let ((dir (if arg default-directory (vc-root-dir))))
      (vc-dir dir)))

  (if (version< emacs-version "28")
      (global-set-key (kbd "C-x v d") 'ts-vc-dir)
    (global-set-key (kbd "C-x v d") 'vc-dir-root))
#+end_src

** View mode

Provide pager-like keybindings. Makes navigating read-only buffers a breeze.
Move down and up with SPC and delete (backspace) or S-SPC, half a page down and
up with d and u, and isearch with s.

Prolific emacser Omar Antolin Camarena points out a built-in way to use
view-mode in all read-only buffers, including ones you set read-only with C-x
C-q.

#+begin_src emacs-lisp
  (setq view-read-only t)
#+end_src

** Whitespace

#+begin_src emacs-lisp
  (with-eval-after-load 'whitespace
    (setq whitespace-line-column 120)
    (setq whitespace-style '(face
                             tabs
                             spaces
                             trailing
                             lines
                             space-before-tab::space
                             newline
                             indentation::space
                             empty
                             space-after-tab::space
                             space-mark
                             tab-mark
                             newline-mark)
          whitespace-face 'whitespace-trailing)
    (global-set-key (kbd "C-c M-w") 'whitespace-mode)
    (message "Lazy loaded whitespace :-)"))
#+end_src

Cleanup whitespace on save

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src

** Windmove

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c w b") 'windmove-left)
  (global-set-key (kbd "C-c w f") 'windmove-right)
  (global-set-key (kbd "C-c w p") 'windmove-up)
  (global-set-key (kbd "C-c w n") 'windmove-down)

  (global-set-key (kbd "C-c w C-b") 'windmove-swap-states-left)
  (global-set-key (kbd "C-c w C-f") 'windmove-swap-states-right)
  (global-set-key (kbd "C-c w C-p") 'windmove-swap-states-up)
  (global-set-key (kbd "C-c w C-n") 'windmove-swap-states-down)

  (with-eval-after-load 'windmove
    (setq windmove-wrap-around t)
    (message "Lazy loaded windmove :-)"))
#+end_src

** Window Divider

#+begin_src emacs-lisp
  (setq window-divider-default-right-width 1)
  (setq window-divider-default-bottom-width 1)
  (setq window-divider-default-places 'right-only)
  (add-hook 'window-setup-hook 'window-divider-mode)
#+end_src

** Winner mode

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Startup-Summary.html#Startup-Summary][Startup Summary]]

#+begin_src emacs-lisp
  (add-hook 'window-setup-hook 'winner-mode)
  (global-set-key (kbd "C-c w u") 'winner-undo)
  (global-set-key (kbd "C-c w r") 'winner-redo)
#+end_src

* MELPA Packages

I like to split up my "vanilla" Emacs configuration and custom functions from
the customisations provided by third party libraries that have been installed
using ~package.el~ and ~use-package~.

If you want to go for a more vanilla setup, just prefix the ~COMMENT~ keyword
to the tile above, and re-tangle the file.

This way it makes it very easy to run a semi-stock Emacs without ~package.el~
or any third party libraries, but still have some saner defaults and some extra
functionality.

I'm using John Wiegley's awesome [[https://github.com/jwiegley/use-package][use-package]] to pull in and configure any third
party packages from [[https://melpa.org/][MELPA]].

** Setup package.el

If we are on an Emacs version lower than "27" this will go in ~init.el~,
otherwise it goes in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][early-init.el]] for faster starup.

#+begin_src emacs-lisp :tangle (if (version< emacs-version "27") init-file "no")
  (if (version< emacs-version "27") (package-initialize))
#+end_src

#+begin_src emacs-lisp :tangle (if (version< emacs-version "27") init-file early-init)
  ;; This must be true otherwise use-package won't load!
  (setq package-enable-at-startup t)
  ;; Allow loading from the package cache.
  (setq package-quickstart t)
  ;; Don't write (package-initialize) to my init file!
  (setq package--init-file-ensured t)
  ;; Turn on ahead-of-time native compilation when installing a package.
  (setq package-native-compile t)
  ;; Setup up archives
  (setq package-archives
        '(("melpa" . "https://melpa.org/packages/")
          ("gnu" . "https://elpa.gnu.org/packages/")))
#+end_src

** use-package bootstrap

#+begin_src emacs-lisp
  (require 'package)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-enable-imenu-support t
        ;; use-package-hook-name-suffix nil
        use-package-always-defer t
        use-package-always-ensure t
        use-package-verbose t)
  (require 'use-package)
#+end_src

** Ansible

#+begin_src emacs-lisp
  (use-package ansible :hook (yaml-mode . ansible))
#+end_src

#+begin_src emacs-lisp
  (use-package ansible-doc :hook (yaml-mode . ansible-doc-mode))
#+end_src

** Async

#+begin_src emacs-lisp
  (use-package async :defer 5
    :commands (async-byte-compile-file
               async-bytecomp-package-mode)
    :init
    (unless (equal system-type 'windows-nt)
      (setq async-bytecomp-allowed-packages '(all)))
    :config
    (if (equal system-type 'windows-nt)
        (async-bytecomp-package-mode -1)
      (async-bytecomp-package-mode 1))
    :hook (dired-mode-hook . dired-async-mode))
#+end_src

** Blacken

#+begin_src emacs-lisp
  (use-package blacken :hook (python-mode . blacken-mode))
#+end_src
** Corfu

Corfu enhances completion at point with a small completion popup. The current
candidates are shown in a popup below or above the point. Corfu is the
minimalistic completion-in-region counterpart of the Vertico minibuffer UI.

https://github.com/minad/corfu

#+begin_src emacs-lisp
  (use-package corfu
    :custom
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-auto t)                 ;; Enable auto completion
    ;; (corfu-separator ?\s)          ;; Orderless field separator
    ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
    ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
    ;; (corfu-preview-current nil)    ;; Disable current candidate preview
    ;; (corfu-preselect-first nil)    ;; Disable candidate preselection
    ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
    ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
    ;; (corfu-scroll-margin 5)        ;; Use scroll margin
    ;; Use TAB for cycling, default is `corfu-complete'.
    :bind
    (:map corfu-map
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))
    :init (global-corfu-mode))
#+end_src

** Diminish

#+begin_src emacs-lisp
  (use-package diminish :defer 2
    :diminish abbrev-mode
    :diminish auto-fill-function ;; wtf?!
    :diminish eldoc-mode
    :diminish hs-minor-mode
    :diminish highlight-changes-mode
    :diminish ts-key-mode
    :diminish org-indent-mode
    :diminish org-src-mode
    :diminish subword-mode
    :hook
    (org-indent-mode . (lambda () (diminish 'org-indent-mode)))
    (hs-minor-mode . (lambda () (diminish 'hs-minor-mode))))
#+end_src

** Diranged

Preview the file or directory at point when in ~dired~, a bit like [[https://github.com/ranger/ranger][ranger]].

Get the source from [[https://github.com/tslight/diranged][here]].

#+begin_src emacs-lisp
  (use-package diranged :ensure nil :after dired
    :load-path "~/src/diranged"
    :bind (:map dired-mode-map ("r" . diranged-mode)))
#+end_src

** Docker

#+begin_src emacs-lisp
  (use-package docker :bind ("C-c C-d" . docker))
#+end_src

#+begin_src emacs-lisp
  (use-package dockerfile-mode)
#+end_src
** Eglot

Emacs Polyglot: an Emacs LSP client that stays out of your way.

https://github.com/joaotavora/eglot

The Language Server Protocol (LSP) defines the protocol used between an editor
or IDE and a language server that provides language features like auto
complete, go to definition, find all references etc. The goal of the Language
Server Index Format (LSIF, pronounced like "else if") is to support rich code
navigation in development tools or a Web UI without needing a local copy of the
source code.

https://microsoft.github.io/language-server-protocol/

#+begin_src shell :tangle no
  pip install python-lsp-server
  go install golang.org/x/tools/gopls@latest
  npm install -g typescript-language-server typescript
  npm install -g bash-language-server
  npm install -g dockerfile-language-server-nodejs
#+end_src

#+begin_src emacs-lisp
  (use-package eglot
    :hook
    (prog-mode . eglot-ensure)
    (shell-script-mode . eglot-ensure))
#+end_src

** COMMENT Elpy

Elpy is an Emacs package to bring powerful Python editing to Emacs. It combines
and configures a number of other packages, both written in Emacs Lisp as well
as Python.

https://github.com/jorgenschaefer/elpy

https://elpy.readthedocs.io/en/latest/index.html

#+begin_src emacs-lisp
  (use-package elpy :init (advice-add 'python-mode :before 'elpy-enable))
#+end_src

** Exec path from shell

Don't tangle this block if ~system-type~ is ~windows-nt~.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package exec-path-from-shell :defer 10
    :unless (eq system-type 'windows-nt)
    :commands exec-path-from-shell-initialize
    :init
    (setq exec-path-from-shell-check-startup-files 'nil)
    :config
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-env "PYTHONPATH"))
#+end_src

** Flycheck

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package flycheck
    :unless (eq system-type 'windows-nt)
    :diminish flycheck-mode
    :config
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    :hook
    (prog-mode . flycheck-mode)
    (shell-script-mode . flycheck-mode))
#+end_src

** Git
*** Gitlab CI

#+begin_src emacs-lisp
  (use-package gitlab-ci-mode
    :mode
    "\\.gitlab-ci.yaml\\'"
    "\\.gitlab-ci.yml\\'"
    :hook
    (yaml-mode . hs-minor-mode))
#+end_src

*** Git Timemachine

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

*** Lazygit

Clone some or all of my projects on GitLab or GitHub via the magic of APIs and
Emacs' ~completing-read~.

Get the source from [[https://gitlab.com/tslight/lazygit][here]].

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package lazygit :ensure nil
    :unless (eq system-type 'windows-nt)
    :load-path "~/src/lazygit.el"
    :bind-keymap
    ("C-c g" . lazygit-map))

  (use-package lazygitlab :ensure nil
    :unless (eq system-type 'windows-nt)
    :load-path "~/src/lazygit.el"
    :bind-keymap
    ("C-c L" . lazygitlab-map))

  (use-package lazygithub :ensure nil
    :unless (eq system-type 'windows-nt)
    :load-path "~/src/lazygit.el"
    :bind-keymap
    ("C-c H" . lazygithub-map))
#+end_src

*** Magit

#+begin_src emacs-lisp
  (use-package magit
    :bind*
    ("C-x g" . magit-status)
    :config
    (when (eq system-type 'windows-nt)
      (if (file-readable-p "C:/Program Files/Git/bin/git.exe")
          (setq magit-git-executable "C:/Program Files/Git/bin/git.exe"))
      (when (file-directory-p "C:/Program Files/Git/bin")
        (setq exec-path (add-to-list 'exec-path "C:/Program Files/Git/bin"))
        (setenv "PATH" (concat "C:\\Program Files\\Git\\bin;" (getenv "PATH")))))
    (setq magit-clone-set-remote.pushDefault t)
    (setq magit-completing-read-function 'magit-builtin-completing-read))
#+end_src

#+begin_src emacs-lisp
  (use-package magit-repos :ensure nil
    :bind* ("C-x C-g" . magit-list-repositories)
    :config
    (setq magit-repository-directories `(("~/" . 0)
                                         ("~/src" . 10)))
    (setq magit-repolist-columns
          '(("Name" 25 magit-repolist-column-ident)
            ;; ("Version" 25 magit-repolist-column-version)
            ("Pull" 5 magit-repolist-column-unpulled-from-upstream)
            ("Push" 5 magit-repolist-column-unpushed-to-upstream)
            ("Commit" 8 magit-repolist-column-flag t)
            ("Path" 99 magit-repolist-column-path))))
#+end_src

Don't tangle this block if ~system-type~ is ~windows-nt~.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package forge :unless (equal system-type 'windows-nt) :after magit)
#+end_src

** Go mode

#+begin_src emacs-lisp
  (use-package go-mode
    :config
    (defun ts-go-indent ()
      (setq indent-tabs-mode 1)
      (setq tab-width 2))
    :hook
    (go-mode . ts-go-indent)
    (before-save . gofmt-before-save))
#+end_src

** Hungry delete

#+begin_src emacs-lisp
  (use-package hungry-delete :defer 6 :config (global-hungry-delete-mode))
#+end_src

** JS2 mode

#+begin_src emacs-lisp
  (use-package js2-mode
    :hook
    (js-mode . js2-minor-mode)
    (js2-mode . js2-imenu-extras-mode)
    :mode
    "\\.js\\'")

  (use-package js2-refactor
    :hook (js2-mode . js2-refactor-mode)
    :bind (:map js2-mode-map
                ("C-k" . js2r-kill))
    :config (js2r-add-keybindings-with-prefix "C-c C-j"))
#+end_src

** JSON

#+begin_src emacs-lisp
  (use-package json-mode
    :config
    (defun ts-json-mode-setup ()
      (json-mode)
      (json-pretty-print (point-min) (point-max))
      (goto-char (point-min))
      (set-buffer-modified-p nil))
    (add-to-list 'auto-mode-alist
                 '("\\.json\\'" . 'ts-json-mode-setup)))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package json-navigator)
#+end_src

** COMMENT Kubel

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package kubel :unless (equal system-type 'windows-nt))
#+end_src

** Markdown

#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . gfm-mode)
           ("\\.markdown\\'" . gfm-mode))
    :init (setq markdown-command "multimarkdown"))
#+end_src

** COMMENT Node JS

#+begin_src emacs-lisp
  (use-package nodejs-repl
    :bind (:map js2-mode-map
                ("C-x C-e" . nodejs-repl-send-last-expression)
                ("C-c C-j" . nodejs-repl-send-line)
                ("C-c SPC" . nodejs-repl-send-region)
                ("C-c C-b" . nodejs-repl-send-buffer)
                ("C-c C-f" . nodejs-repl-load-file)
                ("C-c C-z" . nodejs-repl-switch-to-repl)))
#+end_src

** Org
*** htmlize

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

*** COMMENT Org Bullets

#+begin_src emacs-lisp
  (use-package org-bullets :hook (org-mode . org-bullets-mode))
#+end_src

*** COMMENT PDF Tools

Don't tangle this block if ~system-type~ is ~windows-nt~.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package pdf-tools :unless (eq system-type 'windows-nt))
#+end_src

*** COMMENT Toc Org

#+begin_src emacs-lisp
  (use-package toc-org :hook (org-mode . toc-org-enable))
#+end_src

*** COMMENT Ox TWBS

#+begin_src emacs-lisp
  (use-package ox-twbs)
#+end_src

** Powershell

#+begin_src emacs-lisp
  (use-package powershell :mode (("\\.ps1\\'" . powershell-mode)))
#+end_src

** Projectile

Don't tangle this block if ~emacs-version~ > 28, as Emacs 28 has the this
functionality built in via ~project.el~.

#+begin_src emacs-lisp :tangle (if (version< emacs-version "28") init-file "no")
  (use-package projectile :diminish
    :unless (not (version< emacs-version "28"))
    :bind-keymap
    ("C-x p" . projectile-command-map)
    :config
    (projectile-mode)
    ;; (setq projectile-completion-system 'ivy)
    (when (require 'magit nil t)
      (mapc #'projectile-add-known-project
            (mapcar #'file-name-as-directory (magit-list-repos)))
      ;; Optionally write to persistent `projectile-known-projects-file'
      (projectile-save-known-projects)))
#+end_src

** Restclient

#+begin_src emacs-lisp
  (use-package restclient)
#+end_src

** systemd

Don't tangle this block if ~system-type~ is ~windows-nt~.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "no" init-file)
  (use-package systemd :unless (equal system-type 'windows-nt))
#+end_src

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode)
#+end_src

** Trashed

#+begin_src emacs-lisp
  (use-package trashed :bind ("C-c f t" . trashed))
#+end_src

** Web Mode

#+begin_src emacs-lisp
  (use-package web-mode
    :mode
    "\\.phtml\\'"
    "\\.tpl\\.php\\'"
    "\\.[agj]sp\\'"
    "\\.as[cp]x\\'"
    "\\.erb\\'"
    "\\.mustache\\'"
    "\\.djhtml\\'"
    "\\.html\\.twig\\'"
    "\\.html?\\'"
    "\\.php?\\'"
    "\\.css?\\'"
    :hook
    (web-mode . js2-minor-mode)
    :config
    (setq web-mode-content-type "jsx"
          web-mode-enable-auto-quoting nil
          web-mode-code-indent-offset 2
          web-mode-markup-indent-offset 2
          web-mode-attr-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-enable-auto-pairing t
          web-mode-enable-css-colorization t
          web-mode-enable-block-face t
          web-mode-enable-part-face t
          web-mode-enable-comment-keywords t)
    (add-to-list 'web-mode-indentation-params '("lineup-args" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-calls" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-concats" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-ternary" . nil)))
#+end_src

** Which Key

#+begin_src emacs-lisp
  (use-package which-key :defer 5 :config (which-key-mode))
#+end_src

** Writeable Grep

#+begin_src emacs-lisp
  (use-package wgrep :commands wgrep
    :bind (:map grep-mode-map
                ("e" . wgrep-change-to-wgrep-mode)
                ("C-x C-q" . wgrep-change-to-wgrep-mode)))
#+end_src

** YAML

#+begin_src emacs-lisp
  (use-package highlight-indentation)
#+end_src

#+begin_src emacs-lisp
  (use-package yaml-mode
    :hook
    (yaml-mode . highlight-indentation-mode)
    (yaml-mode . hs-minor-mode)
    (yaml-mode . display-line-numbers-mode))
#+end_src

** Yasnippet

#+begin_src emacs-lisp
  (use-package yasnippet :hook (prog-mode . yas-minor-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package yasnippet-classic-snippets)
#+end_src

#+begin_src emacs-lisp
  (use-package yasnippet-snippets)
#+end_src

* COMMENT Local Variables                                  :NOEXPORT:ARCHIVE:
# Local Variables:
# eval: (setq init-file (expand-file-name "init.el" user-emacs-directory))
# eval: (setq early-init (expand-file-name "early-init.el" user-emacs-directory))
# eval: (add-hook 'after-save-hook 'org-babel-tangle nil t)
# End:
